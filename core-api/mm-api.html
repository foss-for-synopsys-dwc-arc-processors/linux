

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Memory Management APIs &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The genalloc/genpool subsystem" href="genalloc.html" />
    <link rel="prev" title="DMA with ISA and LPC devices" href="dma-isa-lpc.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.16.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-utilities">Core utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#memory-management">Memory management</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="memory-allocation.html">Memory Allocation Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="unaligned-memory-access.html">Unaligned Memory Accesses</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma-api.html">Dynamic DMA mapping using the generic device</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma-api-howto.html">Dynamic DMA mapping Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma-attributes.html">DMA attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma-isa-lpc.html">DMA with ISA and LPC devices</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Memory Management APIs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#user-space-memory-access">User Space Memory Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-allocation-controls">Memory Allocation Controls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-slab-cache">The Slab Cache</a></li>
<li class="toctree-l4"><a class="reference internal" href="#virtually-contiguous-mappings">Virtually Contiguous Mappings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#file-mapping-and-page-cache">File Mapping and Page Cache</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-pools">Memory pools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-pools">DMA pools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#more-memory-management-functions">More Memory Management Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="genalloc.html">The genalloc/genpool subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="pin_user_pages.html">pin_user_pages() and related calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="boot-time-mm.html">Boot time memory management</a></li>
<li class="toctree-l3"><a class="reference internal" href="gfp_mask-from-fs-io.html">GFP masks used from FS/IO context</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Core API Documentation</a> &raquo;</li>
        
      <li>Memory Management APIs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/core-api/mm-api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="memory-management-apis">
<h1>Memory Management APIs<a class="headerlink" href="#memory-management-apis" title="Permalink to this headline">¶</a></h1>
<div class="section" id="user-space-memory-access">
<h2>User Space Memory Access<a class="headerlink" href="#user-space-memory-access" title="Permalink to this headline">¶</a></h2>
<dl class="c macro">
<dt class="sig sig-object c" id="c.access_ok">
<span class="sig-name descname"><span class="n"><span class="pre">access_ok</span></span></span><a class="headerlink" href="#c.access_ok" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">access_ok</span> <span class="pre">(addr,</span> <span class="pre">size)</span></code></p>
<blockquote>
<div><p>Checks if a user space pointer is valid</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>User space pointer to start of block to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of block to check</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>Checks if a pointer to a block of memory in user space is valid.</p>
<p>Note that, depending on architecture, this function probably just
checks that the pointer is in the user space range - after calling
this function, memory access functions may still return -EFAULT.</p>
<p><strong>Return</strong></p>
<p>true (nonzero) if the memory block may be valid, false (zero)
if it is definitely invalid.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.get_user">
<span class="sig-name descname"><span class="n"><span class="pre">get_user</span></span></span><a class="headerlink" href="#c.get_user" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">get_user</span> <span class="pre">(x,</span> <span class="pre">ptr)</span></code></p>
<blockquote>
<div><p>Get a simple variable from user space.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>Variable to store result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>Source address, in user space.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and the result of
dereferencing <strong>ptr</strong> must be assignable to <strong>x</strong> without a cast.</p>
<p><strong>Return</strong></p>
<p>zero on success, or -EFAULT on error.
On error, the variable <strong>x</strong> is set to zero.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.__get_user">
<span class="sig-name descname"><span class="n"><span class="pre">__get_user</span></span></span><a class="headerlink" href="#c.__get_user" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">__get_user</span> <span class="pre">(x,</span> <span class="pre">ptr)</span></code></p>
<blockquote>
<div><p>Get a simple variable from user space, with less checking.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>Variable to store result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>Source address, in user space.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and the result of
dereferencing <strong>ptr</strong> must be assignable to <strong>x</strong> without a cast.</p>
<p>Caller must check the pointer with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal notranslate"><span class="pre">access_ok()</span></code></a> before calling this
function.</p>
<p><strong>Return</strong></p>
<p>zero on success, or -EFAULT on error.
On error, the variable <strong>x</strong> is set to zero.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.put_user">
<span class="sig-name descname"><span class="n"><span class="pre">put_user</span></span></span><a class="headerlink" href="#c.put_user" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">put_user</span> <span class="pre">(x,</span> <span class="pre">ptr)</span></code></p>
<blockquote>
<div><p>Write a simple value into user space.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>Value to copy to user space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>Destination address, in user space.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and <strong>x</strong> must be assignable
to the result of dereferencing <strong>ptr</strong>.</p>
<p><strong>Return</strong></p>
<p>zero on success, or -EFAULT on error.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.__put_user">
<span class="sig-name descname"><span class="n"><span class="pre">__put_user</span></span></span><a class="headerlink" href="#c.__put_user" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">__put_user</span> <span class="pre">(x,</span> <span class="pre">ptr)</span></code></p>
<blockquote>
<div><p>Write a simple value into user space, with less checking.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>Value to copy to user space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>Destination address, in user space.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and <strong>x</strong> must be assignable
to the result of dereferencing <strong>ptr</strong>.</p>
<p>Caller must check the pointer with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal notranslate"><span class="pre">access_ok()</span></code></a> before calling this
function.</p>
<p><strong>Return</strong></p>
<p>zero on success, or -EFAULT on error.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.clear_user">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_user</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">to</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Zero a block of memory in user space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*to</span></code></dt><dd><p>Destination address, in user space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>Number of bytes to zero.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Zero a block of memory in user space.</p>
<p><strong>Return</strong></p>
<p>number of bytes that could not be cleared.
On success, this will be zero.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.__clear_user">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__clear_user</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">to</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__clear_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Zero a block of memory in user space, with less checking.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*to</span></code></dt><dd><p>Destination address, in user space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>Number of bytes to zero.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Zero a block of memory in user space.  Caller must check
the specified block with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal notranslate"><span class="pre">access_ok()</span></code></a> before calling this function.</p>
<p><strong>Return</strong></p>
<p>number of bytes that could not be cleared.
On success, this will be zero.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_user_pages_fast">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_user_pages_fast</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">gup_flags</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_user_pages_fast" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>pin user pages in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>starting user address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>number of pages from start to pin</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">gup_flags</span></code></dt><dd><p>flags modifying pin behaviour</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>array that receives pointers to the pages pinned.
Should be at least nr_pages long.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to pin user pages in memory without taking mm-&gt;mmap_lock.
If not successful, it will fall back to taking the lock and
calling get_user_pages().</p>
<p>Returns number of pages pinned. This may be fewer than the number requested.
If nr_pages is 0 or negative, returns 0. If no pages were pinned, returns
-errno.</p>
</div>
<div class="section" id="memory-allocation-controls">
<span id="mm-api-gfp-flags"></span><h2>Memory Allocation Controls<a class="headerlink" href="#memory-allocation-controls" title="Permalink to this headline">¶</a></h2>
<dl class="c type">
<dt class="sig sig-object c" id="c.gfp_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gfp_t</span></span></span><a class="headerlink" href="#c.gfp_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Memory allocation flags.</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>GFP flags are commonly used throughout Linux to indicate how memory
should be allocated.  The GFP acronym stands for get_free_pages(),
the underlying memory allocation function.  Not every GFP flag is
supported by every function which may allocate memory.  Most users
will want to use a plain <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gfpflags_normal_context">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gfpflags_normal_context</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp_flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gfpflags_normal_context" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is gfp_flags a normal sleepable context?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">gfp_t</span> <span class="pre">gfp_flags</span></code></dt><dd><p>gfp_flags to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test whether <strong>gfp_flags</strong> indicates that the allocation is from the
<code class="docutils literal notranslate"><span class="pre">current</span></code> context and allowed to sleep.</p>
<p>An allocation being allowed to block doesn’t mean it owns the <code class="docutils literal notranslate"><span class="pre">current</span></code>
context.  When direct reclaim path tries to allocate memory, the
allocation context is nested inside whatever <code class="docutils literal notranslate"><span class="pre">current</span></code> was doing at the
time of the original allocation.  The nested allocation may be allowed
to block but modifying anything <code class="docutils literal notranslate"><span class="pre">current</span></code> owns can corrupt the outer
context’s expectations.</p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> result from this function indicates that the allocation context
can sleep and use anything that’s associated with <code class="docutils literal notranslate"><span class="pre">current</span></code>.</p>
<div class="section" id="page-mobility-and-placement-hints">
<h3>Page mobility and placement hints<a class="headerlink" href="#page-mobility-and-placement-hints" title="Permalink to this headline">¶</a></h3>
<p>These flags provide hints about how mobile the page is. Pages with similar
mobility are placed within the same pageblocks to minimise problems due
to external fragmentation.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_MOVABLE</span></code> (also a zone modifier) indicates that the page can be
moved by page migration during memory compaction or can be reclaimed.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_RECLAIMABLE</span></code> is used for slab allocations that specify
SLAB_RECLAIM_ACCOUNT and whose pages can be freed via shrinkers.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_WRITE</span></code> indicates the caller intends to dirty the page. Where possible,
these pages will be spread between local zones to avoid all the dirty
pages being in one zone (fair zone allocation policy).</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_HARDWALL</span></code> enforces the cpuset memory allocation policy.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_THISNODE</span></code> forces the allocation to be satisfied from the requested
node with no fallbacks or placement policy enforcements.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_ACCOUNT</span></code> causes the allocation to be accounted to kmemcg.</p>
</div>
<div class="section" id="watermark-modifiers-controls-access-to-emergency-reserves">
<h3>Watermark modifiers – controls access to emergency reserves<a class="headerlink" href="#watermark-modifiers-controls-access-to-emergency-reserves" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_HIGH</span></code> indicates that the caller is high-priority and that granting
the request is necessary before the system can make forward progress.
For example, creating an IO context to clean pages.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_ATOMIC</span></code> indicates that the caller cannot reclaim or sleep and is
high priority. Users are typically interrupt handlers. This may be
used in conjunction with <code class="docutils literal notranslate"><span class="pre">__GFP_HIGH</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_MEMALLOC</span></code> allows access to all memory. This should only be used when
the caller guarantees the allocation will allow more memory to be freed
very shortly e.g. process exiting or swapping. Users either should
be the MM or co-ordinating closely with the VM (e.g. swap over NFS).
Users of this flag have to be extremely careful to not deplete the reserve
completely and implement a throttling mechanism which controls the
consumption of the reserve based on the amount of freed memory.
Usage of a pre-allocated pool (e.g. mempool) should be always considered
before using this flag.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_NOMEMALLOC</span></code> is used to explicitly forbid access to emergency reserves.
This takes precedence over the <code class="docutils literal notranslate"><span class="pre">__GFP_MEMALLOC</span></code> flag if both are set.</p>
</div>
<div class="section" id="reclaim-modifiers">
<h3>Reclaim modifiers<a class="headerlink" href="#reclaim-modifiers" title="Permalink to this headline">¶</a></h3>
<p>Please note that all the following flags are only applicable to sleepable
allocations (e.g. <code class="docutils literal notranslate"><span class="pre">GFP_NOWAIT</span></code> and <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code> will ignore them).</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_IO</span></code> can start physical IO.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_FS</span></code> can call down to the low-level FS. Clearing the flag avoids the
allocator recursing into the filesystem which might already be holding
locks.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_DIRECT_RECLAIM</span></code> indicates that the caller may enter direct reclaim.
This flag can be cleared to avoid unnecessary delays when a fallback
option is available.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_KSWAPD_RECLAIM</span></code> indicates that the caller wants to wake kswapd when
the low watermark is reached and have it reclaim pages until the high
watermark is reached. A caller may wish to clear this flag when fallback
options are available and the reclaim is likely to disrupt the system. The
canonical example is THP allocation where a fallback is cheap but
reclaim/compaction may cause indirect stalls.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_RECLAIM</span></code> is shorthand to allow/forbid both direct and kswapd reclaim.</p>
<p>The default allocator behavior depends on the request size. We have a concept
of so called costly allocations (with order &gt; <code class="docutils literal notranslate"><span class="pre">PAGE_ALLOC_COSTLY_ORDER</span></code>).
!costly allocations are too essential to fail so they are implicitly
non-failing by default (with some exceptions like OOM victims might fail so
the caller still has to check for failures) while costly requests try to be
not disruptive and back off even without invoking the OOM killer.
The following three modifiers might be used to override some of these
implicit rules</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_NORETRY</span></code>: The VM implementation will try only very lightweight
memory direct reclaim to get some memory under memory pressure (thus
it can sleep). It will avoid disruptive actions like OOM killer. The
caller must handle the failure which is quite likely to happen under
heavy memory pressure. The flag is suitable when failure can easily be
handled at small cost, such as reduced throughput</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_RETRY_MAYFAIL</span></code>: The VM implementation will retry memory reclaim
procedures that have previously failed if there is some indication
that progress has been made else where.  It can wait for other
tasks to attempt high level approaches to freeing memory such as
compaction (which removes fragmentation) and page-out.
There is still a definite limit to the number of retries, but it is
a larger limit than with <code class="docutils literal notranslate"><span class="pre">__GFP_NORETRY</span></code>.
Allocations with this flag may fail, but only when there is
genuinely little unused memory. While these allocations do not
directly trigger the OOM killer, their failure indicates that
the system is likely to need to use the OOM killer soon.  The
caller must handle failure, but can reasonably do so by failing
a higher-level request, or completing it only in a much less
efficient manner.
If the allocation does fail, and the caller is in a position to
free some non-essential memory, doing so could benefit the system
as a whole.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_NOFAIL</span></code>: The VM implementation _must_ retry infinitely: the caller
cannot handle allocation failures. The allocation could block
indefinitely but will never return with failure. Testing for
failure is pointless.
New users should be evaluated carefully (and the flag should be
used only when there is no reasonable failure policy) but it is
definitely preferable to use the flag rather than opencode endless
loop around allocator.
Using this flag for costly allocations is _highly_ discouraged.</p>
</div>
<div class="section" id="useful-gfp-flag-combinations">
<h3>Useful GFP flag combinations<a class="headerlink" href="#useful-gfp-flag-combinations" title="Permalink to this headline">¶</a></h3>
<p>Useful GFP flag combinations that are commonly used. It is recommended
that subsystems start with one of these combinations and then set/clear
<code class="docutils literal notranslate"><span class="pre">__GFP_FOO</span></code> flags as necessary.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code> users can not sleep and need the allocation to succeed. A lower
watermark is applied to allow access to “atomic reserves”.
The current implementation doesn’t support NMI and few other strict
non-preemptive contexts (e.g. raw_spin_lock). The same applies to <code class="docutils literal notranslate"><span class="pre">GFP_NOWAIT</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code> is typical for kernel-internal allocations. The caller requires
<code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code> or a lower zone for direct access but can direct reclaim.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_KERNEL_ACCOUNT</span></code> is the same as GFP_KERNEL, except the allocation is
accounted to kmemcg.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_NOWAIT</span></code> is for kernel allocations that should not stall for direct
reclaim, start physical IO or use any filesystem callback.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_NOIO</span></code> will use direct reclaim to discard clean pages or slab pages
that do not require the starting of any physical IO.
Please try to avoid using this flag directly and instead use
memalloc_noio_{save,restore} to mark the whole scope which cannot
perform any IO with a short explanation why. All allocation requests
will inherit GFP_NOIO implicitly.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_NOFS</span></code> will use direct reclaim but will not use any filesystem interfaces.
Please try to avoid using this flag directly and instead use
memalloc_nofs_{save,restore} to mark the whole scope which cannot/shouldn’t
recurse into the FS layer with a short explanation why. All allocation
requests will inherit GFP_NOFS implicitly.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_USER</span></code> is for userspace allocations that also need to be directly
accessibly by the kernel or hardware. It is typically used by hardware
for buffers that are mapped to userspace (e.g. graphics) that hardware
still must DMA to. cpuset limits are enforced for these allocations.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_DMA</span></code> exists for historical reasons and should be avoided where possible.
The flags indicates that the caller requires that the lowest zone be
used (<code class="docutils literal notranslate"><span class="pre">ZONE_DMA</span></code> or 16M on x86-64). Ideally, this would be removed but
it would require careful auditing as some users really require it and
others use the flag to avoid lowmem reserves in <code class="docutils literal notranslate"><span class="pre">ZONE_DMA</span></code> and treat the
lowest zone as a type of emergency reserve.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_DMA32</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">GFP_DMA</span></code> except that the caller requires a 32-bit
address.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_HIGHUSER</span></code> is for userspace allocations that may be mapped to userspace,
do not need to be directly accessible by the kernel but that cannot
move once in use. An example may be a hardware allocation that maps
data directly into userspace but has no addressing limitations.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_HIGHUSER_MOVABLE</span></code> is for userspace allocations that the kernel does not
need direct access to but can use kmap() when access is required. They
are expected to be movable via page reclaim or page migration. Typically,
pages on the LRU would also be allocated with <code class="docutils literal notranslate"><span class="pre">GFP_HIGHUSER_MOVABLE</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_TRANSHUGE</span></code> and <code class="docutils literal notranslate"><span class="pre">GFP_TRANSHUGE_LIGHT</span></code> are used for THP allocations. They
are compound allocations that will generally fail quickly if memory is not
available and will not wake kswapd/kcompactd on failure. The _LIGHT
version does not attempt reclaim/compaction at all and is by default used
in page fault path, while the non-light is used by khugepaged.</p>
</div>
</div>
<div class="section" id="the-slab-cache">
<h2>The Slab Cache<a class="headerlink" href="#the-slab-cache" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmalloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmalloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>how many bytes of memory are required.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>the type of memory to allocate.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>kmalloc is the normal method of allocating memory
for objects smaller than page size in the kernel.</p>
<p>The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN
bytes. For <strong>size</strong> of power of two bytes, the alignment is also guaranteed
to be at least to the size.</p>
<p>The <strong>flags</strong> argument may be one of the GFP flags defined at
include/linux/gfp.h and described at
<a class="reference internal" href="#mm-api-gfp-flags"><span class="std std-ref"><a class="reference internal" href="#"><span class="doc">Memory Management APIs</span></a></span></a></p>
<p>The recommended usage of the <strong>flags</strong> is described at
<a class="reference internal" href="memory-allocation.html#memory-allocation"><span class="std std-ref"><a class="reference internal" href="memory-allocation.html"><span class="doc">Memory Allocation Guide</span></a></span></a></p>
<p>Below is a brief outline of the most useful GFP flags</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code></dt><dd><p>Allocate normal kernel ram. May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GFP_NOWAIT</span></code></dt><dd><p>Allocation will not sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code></dt><dd><p>Allocation will not sleep.  May use emergency pools.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GFP_HIGHUSER</span></code></dt><dd><p>Allocate memory from high memory on behalf of user.</p>
</dd>
</dl>
<p>Also it is possible to set different flags by OR’ing
in one or more of the following additional <strong>flags</strong>:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__GFP_HIGH</span></code></dt><dd><p>This allocation has high priority and may use emergency pools.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__GFP_NOFAIL</span></code></dt><dd><p>Indicate that this allocation is in no way allowed to fail
(think twice before using).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__GFP_NORETRY</span></code></dt><dd><p>If memory is not immediately available,
then give up at once.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__GFP_NOWARN</span></code></dt><dd><p>If allocation fails, don’t issue any warnings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__GFP_RETRY_MAYFAIL</span></code></dt><dd><p>Try really hard to succeed the allocation but fail
eventually.</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmalloc_array">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmalloc_array</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmalloc_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate memory for an array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></dt><dd><p>number of elements.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>element size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>the type of memory to allocate (see kmalloc).</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.krealloc_array">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">krealloc_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">new_n</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">new_size</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.krealloc_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reallocate memory for an array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>pointer to the memory chunk to reallocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">new_n</span></code></dt><dd><p>new number of elements to alloc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">new_size</span></code></dt><dd><p>new size of a single member of the array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>the type of memory to allocate (see kmalloc)</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.kcalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kcalloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kcalloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate memory for an array. The memory is set to zero.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></dt><dd><p>number of elements.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>element size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>the type of memory to allocate (see kmalloc).</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.kzalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kzalloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kzalloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate memory. The memory is set to zero.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>how many bytes of memory are required.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>the type of memory to allocate (see kmalloc).</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.kzalloc_node">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kzalloc_node</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kzalloc_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate zeroed memory from a particular memory node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>how many bytes of memory are required.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>the type of memory to allocate (see kmalloc).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>memory node from which to allocate</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_cache_alloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cachep</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*cachep</span></code></dt><dd><p>The cache to allocate from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>See <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an object from this cache.  The flags are only relevant
if the cache has no available objects.</p>
<p><strong>Return</strong></p>
<p>pointer to the new object or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_cache_alloc_node">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_alloc_node</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cachep</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nodeid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_alloc_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate an object on the specified node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*cachep</span></code></dt><dd><p>The cache to allocate from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>See <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nodeid</span></code></dt><dd><p>node number of the target node.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Identical to kmem_cache_alloc but it will allocate memory on the given
node, which can improve the performance for cpu bound structures.</p>
<p>Fallback to other node is possible if __GFP_THISNODE is not set.</p>
<p><strong>Return</strong></p>
<p>pointer to the new object or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_cache_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cachep</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deallocate an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*cachep</span></code></dt><dd><p>The cache the allocation was from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*objp</span></code></dt><dd><p>The previously allocated object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free an object which was previously allocated from this
cache.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free previously allocated memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*objp</span></code></dt><dd><p>pointer returned by kmalloc.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>objp</strong> is NULL, no operation is performed.</p>
<p>Don’t free memory not originally allocated by <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>
or you will run into trouble.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.__ksize">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__ksize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__ksize" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>Uninstrumented ksize.</p></li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*objp</span></code></dt><dd><p>pointer to the object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.ksize" title="ksize"><code class="xref c c-func docutils literal notranslate"><span class="pre">ksize()</span></code></a>, <a class="reference internal" href="#c.__ksize" title="__ksize"><code class="xref c c-func docutils literal notranslate"><span class="pre">__ksize()</span></code></a> is uninstrumented, and does not provide the same
safety checks as <a class="reference internal" href="#c.ksize" title="ksize"><code class="xref c c-func docutils literal notranslate"><span class="pre">ksize()</span></code></a> with KASAN instrumentation enabled.</p>
<p><strong>Return</strong></p>
<p>size of the actual memory used by <strong>objp</strong> in bytes</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_cache_create_usercopy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_create_usercopy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="n"><span class="pre">slab_flags_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">useroffset</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">usersize</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctor</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_create_usercopy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a cache with a region suitable for copying to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>A string which is used in /proc/slabinfo to identify this cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>The size of objects to be created in this cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">align</span></code></dt><dd><p>The required alignment for the objects.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slab_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>SLAB flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">useroffset</span></code></dt><dd><p>Usercopy region offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">usersize</span></code></dt><dd><p>Usercopy region size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*ctor)(void</span> <span class="pre">*)</span></code></dt><dd><p>A constructor for the objects.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cannot be called within a interrupt, but can be interrupted.
The <strong>ctor</strong> is run when new pages are allocated by the cache.</p>
<p>The flags are</p>
<p><code class="docutils literal notranslate"><span class="pre">SLAB_POISON</span></code> - Poison the slab with a known test pattern (a5a5a5a5)
to catch references to uninitialised memory.</p>
<p><code class="docutils literal notranslate"><span class="pre">SLAB_RED_ZONE</span></code> - Insert <cite>Red</cite> zones around the allocated memory to check
for buffer overruns.</p>
<p><code class="docutils literal notranslate"><span class="pre">SLAB_HWCACHE_ALIGN</span></code> - Align the objects in this cache to a hardware
cacheline.  This can be beneficial if you’re counting cycles as closely
as davem.</p>
<p><strong>Return</strong></p>
<p>a pointer to the cache on success, NULL on failure.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_cache_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="n"><span class="pre">slab_flags_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctor</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a cache.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>A string which is used in /proc/slabinfo to identify this cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>The size of objects to be created in this cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">align</span></code></dt><dd><p>The required alignment for the objects.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slab_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>SLAB flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*ctor)(void</span> <span class="pre">*)</span></code></dt><dd><p>A constructor for the objects.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cannot be called within a interrupt, but can be interrupted.
The <strong>ctor</strong> is run when new pages are allocated by the cache.</p>
<p>The flags are</p>
<p><code class="docutils literal notranslate"><span class="pre">SLAB_POISON</span></code> - Poison the slab with a known test pattern (a5a5a5a5)
to catch references to uninitialised memory.</p>
<p><code class="docutils literal notranslate"><span class="pre">SLAB_RED_ZONE</span></code> - Insert <cite>Red</cite> zones around the allocated memory to check
for buffer overruns.</p>
<p><code class="docutils literal notranslate"><span class="pre">SLAB_HWCACHE_ALIGN</span></code> - Align the objects in this cache to a hardware
cacheline.  This can be beneficial if you’re counting cycles as closely
as davem.</p>
<p><strong>Return</strong></p>
<p>a pointer to the cache on success, NULL on failure.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_cache_shrink">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_shrink</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cachep</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_shrink" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Shrink a cache.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*cachep</span></code></dt><dd><p>The cache to shrink.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases as many slabs as possible for a cache.
To help debugging, a zero exit status indicates all slabs were released.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> if all slabs were released, non-zero otherwise</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_valid_obj">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmem_valid_obj</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">object</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_valid_obj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>does the pointer reference a valid slab object?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*object</span></code></dt><dd><p>pointer to query.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the pointer is to a not-yet-freed object from
<a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> or <a class="reference internal" href="#c.kmem_cache_alloc" title="kmem_cache_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_alloc()</span></code></a>, either <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code> if the pointer
is to an already-freed object, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_dump_obj">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmem_dump_obj</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">object</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_dump_obj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Print available slab provenance information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*object</span></code></dt><dd><p>slab object for which to find provenance information.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function uses <a class="reference internal" href="printk-basics.html#c.pr_cont" title="pr_cont"><code class="xref c c-func docutils literal notranslate"><span class="pre">pr_cont()</span></code></a>, so that the caller is expected to have
printed out whatever preamble is appropriate.  The provenance information
depends on the type of object and on how much debugging is enabled.
For a slab-cache object, the fact that it is a slab object is printed,
and, if available, the slab name, return address, and stack trace from
the allocation and last free path of that object.</p>
<p>This function will splat if passed a pointer to a non-slab object.
If you are not sure what type of object you have, you should instead
use mem_dump_obj().</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.krealloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">krealloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">new_size</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.krealloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reallocate memory. The contents will remain unchanged.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>object to reallocate memory for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">new_size</span></code></dt><dd><p>how many bytes of memory are required.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>the type of memory to allocate.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The contents of the object pointed to are preserved up to the
lesser of the new and old sizes (__GFP_ZERO flag is effectively ignored).
If <strong>p</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <a class="reference internal" href="#c.krealloc" title="krealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">krealloc()</span></code></a> behaves exactly like <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>.  If <strong>new_size</strong>
is 0 and <strong>p</strong> is not a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer, the object pointed to is freed.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated memory or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfree_sensitive">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfree_sensitive</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_sensitive" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear sensitive information in memory before freeing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>object to free memory of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The memory of the object <strong>p</strong> points to is zeroed before freed.
If <strong>p</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <a class="reference internal" href="#c.kfree_sensitive" title="kfree_sensitive"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_sensitive()</span></code></a> does nothing.</p>
<p><strong>Note</strong></p>
<p>this function zeroes the whole allocated buffer which can be a good
deal bigger than the requested buffer size passed to <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>. So be
careful when using this function in performance sensitive code.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.ksize">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ksize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ksize" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the actual amount of memory allocated for a given object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*objp</span></code></dt><dd><p>Pointer to the object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>kmalloc may internally round up allocations and return more memory
than requested. <a class="reference internal" href="#c.ksize" title="ksize"><code class="xref c c-func docutils literal notranslate"><span class="pre">ksize()</span></code></a> can be used to determine the actual amount of
memory allocated. The caller may use this additional memory, even though
a smaller amount of memory was initially specified with the kmalloc call.
The caller must guarantee that objp points to a valid object previously
allocated with either <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> or <a class="reference internal" href="#c.kmem_cache_alloc" title="kmem_cache_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_alloc()</span></code></a>. The object
must not be freed during the duration of the call.</p>
<p><strong>Return</strong></p>
<p>size of the actual memory used by <strong>objp</strong> in bytes</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfree_const">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfree_const</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_const" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>conditionally free memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*x</span></code></dt><dd><p>pointer to the memory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function calls kfree only if <strong>x</strong> is not in .rodata section.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kvmalloc_node">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kvmalloc_node</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kvmalloc_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>attempt to allocate physically contiguous memory, but upon failure, fall back to non-contiguous (vmalloc) allocation.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>gfp mask for the allocation - must be compatible (superset) with GFP_KERNEL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>numa node to allocate from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses kmalloc to get the memory but if the allocation fails then falls back
to the vmalloc allocator. Use kvfree for freeing the memory.</p>
<p>Reclaim modifiers - __GFP_NORETRY and __GFP_NOFAIL are not supported.
__GFP_RETRY_MAYFAIL is supported, and it should be used only if kmalloc is
preferable to the vmalloc fallback, due to visible performance drawbacks.</p>
<p>Please note that any use of gfp flags outside of GFP_KERNEL is careful to not
fall back to vmalloc.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated memory of <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of failure</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kvfree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kvfree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kvfree" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to allocated memory.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>kvfree frees memory allocated by any of <a class="reference internal" href="#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>, <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> or kvmalloc().
It is slightly more efficient to use <a class="reference internal" href="#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> or <a class="reference internal" href="#c.vfree" title="vfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfree()</span></code></a> if you are certain
that you know which one to use.</p>
<p><strong>Context</strong></p>
<p>Either preemptible task context or not-NMI interrupt.</p>
</div>
<div class="section" id="virtually-contiguous-mappings">
<h2>Virtually Contiguous Mappings<a class="headerlink" href="#virtually-contiguous-mappings" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_unmap_aliases">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_unmap_aliases</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_unmap_aliases" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unmap outstanding lazy aliases in the vmap layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vmap/vmalloc layer lazily flushes kernel virtual mappings primarily
to amortize TLB flushing overheads. What this means is that any page you
have now, may, in a former life, have been mapped into kernel virtual
address by the vmap layer and so there might be some CPUs with TLB entries
still referencing that page (additional to the regular 1:1 kernel mapping).</p>
<p>vm_unmap_aliases flushes all such lazy mappings. After it returns, we can
be sure that none of the pages we have control over will have any aliases
from the vmap layer.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_unmap_ram">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_unmap_ram</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mem</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_unmap_ram" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unmap linear kernel address space set up by vm_map_ram</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*mem</span></code></dt><dd><p>the pointer returned by vm_map_ram</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the count passed to that vm_map_ram call (cannot unmap partial)</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_map_ram">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vm_map_ram</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_map_ram" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map pages linearly into kernel virtual address (vmalloc space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>an array of pointers to the pages to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>number of pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>prefer to allocate data structures on this node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you use this function for less than VMAP_MAX_ALLOC pages, it could be
faster than vmap so it’s good.  But if you mix long-life and short-life
objects with <a class="reference internal" href="#c.vm_map_ram" title="vm_map_ram"><code class="xref c c-func docutils literal notranslate"><span class="pre">vm_map_ram()</span></code></a>, it could consume lots of address space through
fragmentation (especially on a 32bit machine).  You could see failures in
the end.  Please use this function for short-lived objects.</p>
<p><strong>Return</strong></p>
<p>a pointer to the address that has been mapped, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vfree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vfree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vfree" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release memory allocated by <a class="reference internal" href="#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>Memory base address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the virtually continuous memory area starting at <strong>addr</strong>, as obtained
from one of the <a class="reference internal" href="#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a> family of APIs.  This will usually also free the
physical memory underlying the virtual allocation, but that memory is
reference counted, so it will not be freed until the last user goes away.</p>
<p>If <strong>addr</strong> is NULL, no operation is performed.</p>
<p><strong>Context</strong></p>
<p>May sleep if called <em>not</em> from interrupt context.
Must not be called in NMI context (strictly speaking, it could be
if we have CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG, but making the calling
conventions for <a class="reference internal" href="#c.vfree" title="vfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfree()</span></code></a> arch-dependent would be a really bad idea).</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vunmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vunmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vunmap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release virtual mapping obtained by <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmap()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>memory base address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the virtually contiguous memory area starting at <strong>addr</strong>,
which was created from the page array passed to <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmap()</span></code></a>.</p>
<p>Must not be called in interrupt context.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="n"><span class="pre">pgprot_t</span></span><span class="w"> </span><span class="n"><span class="pre">prot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map an array of pages into virtually contiguous space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>array of page pointers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>number of pages to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>vm_area-&gt;flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt><dd><p>page protection for the mapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps <strong>count</strong> pages from <strong>pages</strong> into contiguous kernel virtual space.
If <strong>flags</strong> contains <code class="docutils literal notranslate"><span class="pre">VM_MAP_PUT_PAGES</span></code> the ownership of the pages array itself
(which must be kmalloc or vmalloc memory) and one reference per pages in it
are transferred from the caller to <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmap()</span></code></a>, and will be freed / dropped when
<a class="reference internal" href="#c.vfree" title="vfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfree()</span></code></a> is called on the return value.</p>
<p><strong>Return</strong></p>
<p>the address of the area or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmap_pfn">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vmap_pfn</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pfns</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="n"><span class="pre">pgprot_t</span></span><span class="w"> </span><span class="n"><span class="pre">prot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmap_pfn" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map an array of PFNs into virtually contiguous space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*pfns</span></code></dt><dd><p>array of PFNs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>number of pages to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt><dd><p>page protection for the mapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps <strong>count</strong> PFNs from <strong>pfns</strong> into contiguous kernel virtual space and returns
the start address of the mapping.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.__vmalloc_node">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__vmalloc_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">caller</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__vmalloc_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate virtually contiguous memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align</span></code></dt><dd><p>desired alignment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>flags for the page level allocator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>node to use for allocation or NUMA_NO_NODE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*caller</span></code></dt><dd><p>caller’s return address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate enough pages to cover <strong>size</strong> from the page level allocator with
<strong>gfp_mask</strong> flags.  Map them into contiguous kernel virtual space.</p>
<p>Reclaim modifiers in <strong>gfp_mask</strong> - __GFP_NORETRY, __GFP_RETRY_MAYFAIL
and __GFP_NOFAIL are not supported</p>
<p>Any use of gfp flags outside of GFP_KERNEL should be consulted
with mm people.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated memory or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vmalloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate virtually contiguous memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.</p>
<p>For tight control over page level allocator and protection flags
use __vmalloc() instead.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated memory or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmalloc_no_huge">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vmalloc_no_huge</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_no_huge" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate virtually contiguous memory using small pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate enough non-huge pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated memory or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vzalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vzalloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vzalloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate virtually contiguous memory with zero fill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.
The memory allocated is set to zero.</p>
<p>For tight control over page level allocator and protection flags
use __vmalloc() instead.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated memory or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmalloc_user">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vmalloc_user</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate zeroed virtually contiguous memory for userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The resulting memory area is zeroed so it can be mapped to userspace
without leaking data.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated memory or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmalloc_node">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vmalloc_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate memory on a specific node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>numa node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.</p>
<p>For tight control over page level allocator and protection flags
use __vmalloc() instead.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated memory or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vzalloc_node">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vzalloc_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vzalloc_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate memory on a specific node with zero fill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>numa node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.
The memory allocated is set to zero.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated memory or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmalloc_32">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vmalloc_32</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate virtually contiguous memory (32bit addressable)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate enough 32bit PA addressable pages to cover <strong>size</strong> from the
page level allocator and map them into contiguous kernel virtual space.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated memory or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmalloc_32_user">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vmalloc_32_user</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_32_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate zeroed virtually contiguous 32bit memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The resulting memory area is 32bit addressable and zeroed so it can be
mapped to userspace without leaking data.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated memory or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.remap_vmalloc_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">remap_vmalloc_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pgoff</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_vmalloc_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map vmalloc pages to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>vma to cover (map full range of vma)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>vmalloc memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt><dd><p>number of pages into addr before first page to map</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -Exxx on failure</p>
<p><strong>Description</strong></p>
<p>This function checks that addr is a valid vmalloc’ed area, and
that it is big enough to cover the vma. Will return failure if
that criteria isn’t met.</p>
<p>Similar to <a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">remap_pfn_range()</span></code></a> (see mm/memory.c)</p>
</div>
<div class="section" id="file-mapping-and-page-cache">
<h2>File Mapping and Page Cache<a class="headerlink" href="#file-mapping-and-page-cache" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.read_cache_pages">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">read_cache_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filler</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>populate an address space with some pages &amp; start reads against them</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*pages</span></code></dt><dd><p>The address of a list_head which contains the target pages.  These
pages have their -&gt;index populated and are otherwise uninitialised.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*filler)(void</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*)</span></code></dt><dd><p>callback routine for filling a single page.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>private data for the callback routine.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hides the details of the LRU cache etc from the filesystems.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, error return by <strong>filler</strong> otherwise</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_cache_ra_unbounded">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_cache_ra_unbounded</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ractl</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr_to_read</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">lookahead_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_ra_unbounded" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start unchecked readahead.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*ractl</span></code></dt><dd><p>Readahead control.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr_to_read</span></code></dt><dd><p>The number of pages to read.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">lookahead_size</span></code></dt><dd><p>Where to start the next readahead.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is for filesystems to call when they want to start
readahead beyond a file’s stated i_size.  This is almost certainly
not the function you want to call.  Use <a class="reference internal" href="#c.page_cache_async_readahead" title="page_cache_async_readahead"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_cache_async_readahead()</span></code></a>
or <a class="reference internal" href="#c.page_cache_sync_readahead" title="page_cache_sync_readahead"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_cache_sync_readahead()</span></code></a> instead.</p>
<p><strong>Context</strong></p>
<p>File is referenced by caller.  Mutexes may be held by caller.
May sleep, but will not reenter filesystem to reclaim memory.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_expand">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_expand</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ractl</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">new_start</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">new_len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_expand" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Expand a readahead request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*ractl</span></code></dt><dd><p>The request to be expanded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">new_start</span></code></dt><dd><p>The revised start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">new_len</span></code></dt><dd><p>The revised size of the request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to expand a readahead request outwards from the current size to the
specified size by inserting locked pages before and after the current window
to increase the size to the new window.  This may involve the insertion of
THPs, in which case the window may get expanded even beyond what was
requested.</p>
<p>The algorithm will stop if it encounters a conflicting page already in the
pagecache and leave a smaller expansion than requested.</p>
<p>The caller must check for this by examining the revised <strong>ractl</strong> object for a
different expansion than was requested.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.delete_from_page_cache">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">delete_from_page_cache</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.delete_from_page_cache" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.delete_from_page_cache" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>delete page from page cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the page which the kernel is trying to remove from page cache</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called only on pages that have been verified to be in the page
cache and locked.  It will never put the page into the free list, the caller
has a reference on the page.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_fdatawrite_wbc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_fdatawrite_wbc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">writeback_control</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wbc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawrite_wbc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>start writeback on mapping dirty pages in range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>the writeback_control controlling the writeout</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call writepages on the mapping using the provided wbc to control the
writeout.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_flush">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_flush</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_flush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mostly a non-blocking flush</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>target address_space</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a mostly non-blocking flush.  Not suitable for data-integrity
purposes - I/O may not be started against all dirty pages.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_range_has_page">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_range_has_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start_byte</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end_byte</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_range_has_page" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if a page exists in range.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space within which to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find at least one page in the range supplied, usually used to check if
direct writing in this range will trigger a writeback.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if at least one page exists in the specified range,
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_fdatawait_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_fdatawait_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start_byte</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end_byte</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for writeback to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space
in the given range and wait for all of them.  Check error status of
the address space and return it.</p>
<p>Since the error status of the address space is cleared by this function,
callers are responsible for checking the return value and handling and/or
reporting the error.</p>
<p><strong>Return</strong></p>
<p>error status of the address space.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_fdatawait_range_keep_errors">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_fdatawait_range_keep_errors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start_byte</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end_byte</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_range_keep_errors" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for writeback to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space in the
given range and wait for all of them.  Unlike <a class="reference internal" href="#c.filemap_fdatawait_range" title="filemap_fdatawait_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_fdatawait_range()</span></code></a>,
this function does not clear error status of the address space.</p>
<p>Use this function if callers don’t handle errors themselves.  Expected
call sites are system-wide / filesystem-wide data flushers: e.g. sync(2),
fsfreeze(8)</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.file_fdatawait_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">file_fdatawait_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.file_fdatawait_range" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start_byte</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end_byte</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.file_fdatawait_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for writeback to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file pointing to address space structure to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the address space that file
refers to, in the given range and wait for all of them.  Check error
status of the address space vs. the file-&gt;f_wb_err cursor and return it.</p>
<p>Since the error status of the file is advanced by this function,
callers are responsible for checking the return value and handling and/or
reporting the error.</p>
<p><strong>Return</strong></p>
<p>error status of the address space vs. the file-&gt;f_wb_err cursor.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_fdatawait_keep_errors">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_fdatawait_keep_errors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_keep_errors" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for writeback without clearing errors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space
and wait for all of them.  Unlike filemap_fdatawait(), this function
does not clear error status of the address space.</p>
<p>Use this function if callers don’t handle errors themselves.  Expected
call sites are system-wide / filesystem-wide data flushers: e.g. sync(2),
fsfreeze(8)</p>
<p><strong>Return</strong></p>
<p>error status of the address space.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_range_needs_writeback">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_range_needs_writeback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start_byte</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end_byte</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_range_needs_writeback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if range potentially needs writeback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space within which to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find at least one page in the range supplied, usually used to check if
direct writing in this range will trigger a writeback. Used by O_DIRECT
read/write with IOCB_NOWAIT, to see if the caller needs to do
<a class="reference internal" href="#c.filemap_write_and_wait_range" title="filemap_write_and_wait_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_write_and_wait_range()</span></code></a> before proceeding.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the caller should do <a class="reference internal" href="#c.filemap_write_and_wait_range" title="filemap_write_and_wait_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_write_and_wait_range()</span></code></a> before
doing O_DIRECT to a page in this range, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_write_and_wait_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_write_and_wait_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lstart</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lend</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_write_and_wait_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>write out &amp; wait on a file range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space for the pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write out and wait upon file offsets lstart-&gt;lend, inclusive.</p>
<p>Note that <strong>lend</strong> is inclusive (describes the last byte to be written) so
that this function can be used to write to the very end-of-file (end = -1).</p>
<p><strong>Return</strong></p>
<p>error status of the address space.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.file_check_and_advance_wb_err">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">file_check_and_advance_wb_err</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.file_check_and_advance_wb_err" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.file_check_and_advance_wb_err" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>report wb error (if any) that was previously and advance wb_err to current one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>struct file on which the error is being reported</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When userland calls fsync (or something like nfsd does the equivalent), we
want to report any writeback errors that occurred since the last fsync (or
since the file was opened if there haven’t been any).</p>
<p>Grab the wb_err from the mapping. If it matches what we have in the file,
then just quickly return 0. The file is all caught up.</p>
<p>If it doesn’t match, then take the mapping value, set the “seen” flag in
it and try to swap it into place. If it works, or another task beat us
to it with the new value, then update the f_wb_err and return the error
portion. The error at this point must be reported via proper channels
(a’la fsync, or NFS COMMIT operation, etc.).</p>
<p>While we handle mapping-&gt;wb_err with atomic operations, the f_wb_err
value is protected by the f_lock since we must ensure that it reflects
the latest value swapped in for this file descriptor.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.file_write_and_wait_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">file_write_and_wait_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.file_write_and_wait_range" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lstart</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lend</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.file_write_and_wait_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>write out &amp; wait on a file range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file pointing to address_space with pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write out and wait upon file offsets lstart-&gt;lend, inclusive.</p>
<p>Note that <strong>lend</strong> is inclusive (describes the last byte to be written) so
that this function can be used to write to the very end-of-file (end = -1).</p>
<p>After writing out and waiting on the data, we check and advance the
f_wb_err cursor to the latest value, and return any errors detected there.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.replace_page_cache_page">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">replace_page_cache_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.replace_page_cache_page" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>replace a pagecache page with a new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*old</span></code></dt><dd><p>page to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*new</span></code></dt><dd><p>page to replace with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function replaces a page in the pagecache with a new one.  On
success it acquires the pagecache reference for the new page and
drops it for the old page.  Both the old and new pages must be
locked.  This function does not add the new page to the LRU, the
caller must do that.</p>
<p>The remove + add is atomic.  This function cannot fail.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.add_to_page_cache_locked">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">add_to_page_cache_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.add_to_page_cache_locked" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.add_to_page_cache_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a locked page to the pagecache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the page’s address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt><dd><p>page index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>page allocation mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to add a page to the pagecache. It must be locked.
This function does not add the page to the LRU.  The caller must do that.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_add_wait_queue">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_add_wait_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_wait_queue" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">wait_queue_entry_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">waiter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_add_wait_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add an arbitrary waiter to a folio’s wait queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio defining the wait queue of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_queue_entry_t</span> <span class="pre">*waiter</span></code></dt><dd><p>Waiter to add to the queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an arbitrary <strong>waiter</strong> to the wait queue for the nominated <strong>folio</strong>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_unlock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_unlock" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unlock a locked folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the folio and wakes up any thread sleeping on the page lock.</p>
<p><strong>Context</strong></p>
<p>May be called from interrupt or process context.  May not be
called from NMI context.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_end_private_2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_end_private_2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_end_private_2" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_end_private_2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear PG_private_2 and wake any waiters.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear the PG_private_2 bit on a folio and wake up any sleepers waiting for
it.  The folio reference held for PG_private_2 being set is released.</p>
<p>This is, for example, used when a netfs folio is being written to a local
disk cache, thereby allowing writes to the cache for the same folio to be
serialised.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_wait_private_2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_wait_private_2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_wait_private_2" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_private_2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for PG_private_2 to be cleared on a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to wait on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for PG_private_2 (aka PG_fscache) to be cleared on a folio.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_wait_private_2_killable">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_wait_private_2_killable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_wait_private_2_killable" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_private_2_killable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for PG_private_2 to be cleared on a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to wait on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for PG_private_2 (aka PG_fscache) to be cleared on a folio or until a
fatal signal is received by the calling task.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0 if successful.</p></li>
<li><p>-EINTR if a fatal signal was encountered.</p></li>
</ul>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_end_writeback">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_end_writeback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_end_writeback" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_end_writeback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>End writeback against a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.__folio_lock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__folio_lock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__folio_lock" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__folio_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a lock on the folio, assuming we need to sleep to get it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to lock</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_cache_next_miss">
<span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_cache_next_miss</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max_scan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_next_miss" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the next gap in the page cache.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>Mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>Index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_scan</span></code></dt><dd><p>Maximum range to search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the range [index, min(index + max_scan - 1, ULONG_MAX)] for the
gap with the lowest index.</p>
<p>This function may be called under the rcu_read_lock.  However, this will
not atomically search a snapshot of the cache at a single point in time.
For example, if a gap is created at index 5, then subsequently a gap is
created at index 10, page_cache_next_miss covering both indices may
return 10 if called under the rcu_read_lock.</p>
<p><strong>Return</strong></p>
<p>The index of the gap if found, otherwise an index outside the
range specified (in which case ‘return - index &gt;= max_scan’ will be true).
In the rare case of index wrap-around, 0 will be returned.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_cache_prev_miss">
<span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_cache_prev_miss</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max_scan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_prev_miss" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the previous gap in the page cache.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>Mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>Index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_scan</span></code></dt><dd><p>Maximum range to search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the range [max(index - max_scan + 1, 0), index] for the
gap with the highest index.</p>
<p>This function may be called under the rcu_read_lock.  However, this will
not atomically search a snapshot of the cache at a single point in time.
For example, if a gap is created at index 10, then subsequently a gap is
created at index 5, <a class="reference internal" href="#c.page_cache_prev_miss" title="page_cache_prev_miss"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_cache_prev_miss()</span></code></a> covering both indices may
return 5 if called under the rcu_read_lock.</p>
<p><strong>Return</strong></p>
<p>The index of the gap if found, otherwise an index outside the
range specified (in which case ‘index - return &gt;= max_scan’ will be true).
In the rare case of wrap-around, ULONG_MAX will be returned.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.__filemap_get_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__filemap_get_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">fgp_flags</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__filemap_get_folio" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find and get a reference to a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space to search.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The page index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fgp_flags</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">FGP</span></code> flags modify how the folio is returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags to use if <code class="docutils literal notranslate"><span class="pre">FGP_CREAT</span></code> is specified.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache entry at <strong>mapping</strong> &amp; <strong>index</strong>.</p>
<p><strong>fgp_flags</strong> can be zero or more of these flags:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_ACCESSED</span></code> - The folio will be marked accessed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_LOCK</span></code> - The folio is returned locked.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_ENTRY</span></code> - If there is a shadow / swap / DAX entry, return it
instead of allocating a new folio to replace it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_CREAT</span></code> - If no page is present then a new page is allocated using
<strong>gfp</strong> and added to the page cache and the VM’s LRU list.
The page is returned locked and with an increased refcount.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_FOR_MMAP</span></code> - The caller wants to do its own locking dance if the
page is already in cache.  If the page was allocated, unlock it before
returning so the caller can do the same dance.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_WRITE</span></code> - The page will be written to by the caller.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_NOFS</span></code> - __GFP_FS will get cleared in gfp.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_NOWAIT</span></code> - Don’t get blocked by page lock.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_STABLE</span></code> - Wait for the folio to be stable (finished writeback)</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">FGP_LOCK</span></code> or <code class="docutils literal notranslate"><span class="pre">FGP_CREAT</span></code> are specified then the function may sleep even
if the <code class="docutils literal notranslate"><span class="pre">GFP</span></code> flags specified for <code class="docutils literal notranslate"><span class="pre">FGP_CREAT</span></code> are atomic.</p>
<p>If there is a page cache page, it is returned with an increased refcount.</p>
<p><strong>Return</strong></p>
<p>The found folio or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_get_pages_contig">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_get_pages_contig</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_pages_contig" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>gang contiguous pagecache lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The starting page index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>The maximum number of pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>Where the resulting pages are placed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.find_get_pages_contig" title="find_get_pages_contig"><code class="xref c c-func docutils literal notranslate"><span class="pre">find_get_pages_contig()</span></code></a> works exactly like find_get_pages(), except
that the returned number of pages are guaranteed to be contiguous.</p>
<p><strong>Return</strong></p>
<p>the number of pages which were found.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_get_pages_range_tag">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_get_pages_range_tag</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">index</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="n"><span class="pre">xa_mark_t</span></span><span class="w"> </span><span class="n"><span class="pre">tag</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_pages_range_tag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find and return head pages matching <strong>tag</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">*index</span></code></dt><dd><p>the starting page index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt><dd><p>The final page index (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">tag</span></code></dt><dd><p>the tag index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>the maximum number of pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>where the resulting pages are placed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like find_get_pages(), except we only return head pages which are tagged
with <strong>tag</strong>.  <strong>index</strong> is updated to the index immediately after the last
page we return, ready for the next iteration.</p>
<p><strong>Return</strong></p>
<p>the number of pages which were found.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_read">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kiocb</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iocb</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iov_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span>, <span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="n"><span class="pre">already_read</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read data from the page cache.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>The iocb to read.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*iter</span></code></dt><dd><p>Destination for the data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">already_read</span></code></dt><dd><p>Number of bytes already read by the caller.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data from the page cache.  If the data is not currently present,
uses the readahead and readpage address_space operations to fetch it.</p>
<p><strong>Return</strong></p>
<p>Total number of bytes copied, including those already read by
the caller.  If an error happens before any bytes are copied, returns
a negative error number.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.generic_file_read_iter">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">generic_file_read_iter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kiocb</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iocb</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iov_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_read_iter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>generic filesystem read routine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>kernel I/O control block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*iter</span></code></dt><dd><p>destination for the data read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the “read_iter()” routine for all filesystems
that can use the page cache directly.</p>
<p>The IOCB_NOWAIT flag in iocb-&gt;ki_flags indicates that -EAGAIN shall
be returned when no data can be read without waiting for I/O requests
to complete; it doesn’t prevent readahead.</p>
<p>The IOCB_NOIO flag in iocb-&gt;ki_flags indicates that no new I/O
requests shall be made for the read or for readahead.  When no data
can be read, -EAGAIN shall be returned.  When readahead would be
triggered, a partial, possibly empty read shall be returned.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>number of bytes copied, even for partial reads</p></li>
<li><p>negative error code (or 0 if IOCB_NOIO) if nothing was read</p></li>
</ul>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_fault">
<a class="reference internal" href="#c.vm_fault_t" title="vm_fault_t"><span class="n"><span class="pre">vm_fault_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_fault</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_fault</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vmf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fault" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>read in file data for page fault handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*vmf</span></code></dt><dd><p>struct vm_fault containing details of the fault</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.filemap_fault" title="filemap_fault"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_fault()</span></code></a> is invoked via the vma operations vector for a
mapped memory region to read in file data during a page fault.</p>
<p>The goto’s are kind of ugly, but this streamlines the normal case of having
it in the page cache, and handles the special cases reasonably without
having a lot of duplicated code.</p>
<p>vma-&gt;vm_mm-&gt;mmap_lock must be held on entry.</p>
<p>If our return value has VM_FAULT_RETRY set, it’s because the mmap_lock
may be dropped before doing I/O or by lock_page_maybe_drop_mmap().</p>
<p>If our return value does not have VM_FAULT_RETRY set, the mmap_lock
has not been released.</p>
<p>We never return with VM_FAULT_RETRY and a bit from VM_FAULT_ERROR set.</p>
<p><strong>Return</strong></p>
<p>bitwise-OR of <code class="docutils literal notranslate"><span class="pre">VM_FAULT_</span></code> codes.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.read_cache_page">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">read_cache_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filler</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_page" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>read into page cache, fill it if needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the page’s address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>the page index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*filler)(void</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*)</span></code></dt><dd><p>function to perform the read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>first arg to filler(data, page) function, often left as NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read into the page cache. If a page already exists, and PageUptodate() is
not set, try to fill the page and wait for it to become unlocked.</p>
<p>If the page does not get brought uptodate, return -EIO.</p>
<p>The function expects mapping-&gt;invalidate_lock to be already held.</p>
<p><strong>Return</strong></p>
<p>up to date page on success, ERR_PTR() on failure.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.read_cache_page_gfp">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">read_cache_page_gfp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_page_gfp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>read into page cache, using specified page allocation flags.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the page’s address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>the page index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the page allocator flags to use if allocating</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as “read_mapping_page(mapping, index, NULL)”, but with
any new page allocations done using the specified allocation flags.</p>
<p>If the page does not get brought uptodate, return -EIO.</p>
<p>The function expects mapping-&gt;invalidate_lock to be already held.</p>
<p><strong>Return</strong></p>
<p>up to date page on success, ERR_PTR() on failure.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.__generic_file_write_iter">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__generic_file_write_iter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kiocb</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iocb</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iov_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__generic_file_write_iter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>write data to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>IO state structure (file, offset, etc.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*from</span></code></dt><dd><p>iov_iter with data to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does all the work needed for actually writing data to a
file. It does all basic checks, removes SUID from the file, updates
modification times and calls proper subroutines depending on whether we
do direct IO or a standard buffered write.</p>
<p>It expects i_rwsem to be grabbed unless we work on a block device or similar
object which does not need locking at all.</p>
<p>This function does <em>not</em> take care of syncing data in case of O_SYNC write.
A caller has to handle it. This is mainly due to the fact that we want to
avoid syncing under i_rwsem.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>number of bytes written, even for truncated writes</p></li>
<li><p>negative error code if no data has been written at all</p></li>
</ul>
<dl class="c function">
<dt class="sig sig-object c" id="c.generic_file_write_iter">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">generic_file_write_iter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kiocb</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iocb</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iov_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_write_iter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>write data to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>IO state structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*from</span></code></dt><dd><p>iov_iter with data to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a wrapper around <a class="reference internal" href="#c.__generic_file_write_iter" title="__generic_file_write_iter"><code class="xref c c-func docutils literal notranslate"><span class="pre">__generic_file_write_iter()</span></code></a> to be used by most
filesystems. It takes care of syncing the file in case of O_SYNC file
and acquires i_rwsem as needed.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>negative error code if no data has been written at all of
<a class="reference internal" href="../filesystems/api-summary.html#c.vfs_fsync_range" title="vfs_fsync_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfs_fsync_range()</span></code></a> failed for a synchronous write</p></li>
<li><p>number of bytes written, even for truncated writes</p></li>
</ul>
<dl class="c function">
<dt class="sig sig-object c" id="c.try_to_release_page">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">try_to_release_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.try_to_release_page" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_release_page" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release old fs-specific metadata on a page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the page which the kernel is trying to free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags (and I/O mode)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The address_space is to try to release any data against the page
(presumably at page-&gt;private).</p>
<p>This may also be called if PG_fscache is set on a page, indicating that the
page is known to the local caching routines.</p>
<p>The <strong>gfp_mask</strong> argument specifies whether I/O may be performed to release
this page (__GFP_IO), and whether the call may block (__GFP_RECLAIM &amp; __GFP_FS).</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">1</span></code> if the release was successful, otherwise return zero.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.balance_dirty_pages_ratelimited">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">balance_dirty_pages_ratelimited</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.balance_dirty_pages_ratelimited" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>balance dirty memory state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address_space which was dirtied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes which are dirtying memory should call in here once for each page
which was newly dirtied.  The function will periodically check the system’s
dirty state and will initiate writeback if needed.</p>
<p>Once we’re over the dirty memory limit we decrease the ratelimiting
by a lot, to prevent individual processes from overshooting the limit
by (ratelimit_pages) each.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.tag_pages_for_writeback">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tag_pages_for_writeback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.tag_pages_for_writeback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tag pages to be written by write_cache_pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt><dd><p>starting page index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt><dd><p>ending page index (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function scans the page range from <strong>start</strong> to <strong>end</strong> (inclusive) and tags
all pages that have DIRTY tag set with a special TOWRITE tag. The idea is
that write_cache_pages (or whoever calls this function) will then use
TOWRITE tag to identify pages eligible for writeback.  This mechanism is
used to avoid livelocking of writeback by a process steadily creating new
dirty pages in the file (thus it is important for this function to be quick
so that it can tag pages faster than a dirtying process can create them).</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.write_cache_pages">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">write_cache_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">writeback_control</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wbc</span></span>, <span class="n"><span class="pre">writepage_t</span></span><span class="w"> </span><span class="n"><span class="pre">writepage</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.write_cache_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>walk the list of dirty pages of the given address space and write all of them.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>subtract the number of written pages from <strong>*wbc-&gt;nr_to_write</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writepage_t</span> <span class="pre">writepage</span></code></dt><dd><p>function called for each page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data passed to writepage function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a page is already under I/O, <a class="reference internal" href="#c.write_cache_pages" title="write_cache_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">write_cache_pages()</span></code></a> skips it, even
if it’s dirty.  This is desirable behaviour for memory-cleaning writeback,
but it is INCORRECT for data-integrity system calls such as fsync().  fsync()
and msync() need to guarantee that all the data which was dirty at the time
the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
WB_SYNC_ALL then we were called for data integrity and we must wait for
existing IO to complete.</p>
<p>To avoid livelocks (when other process dirties new pages), we first tag
pages which should be written back with TOWRITE tag and only then start
writing them. For data-integrity sync we have to be careful so that we do
not miss some pages (e.g., because some other process has cleared TOWRITE
tag we set). The rule we follow is that TOWRITE tag can be cleared only
by the process clearing the DIRTY tag (and submitting the page for IO).</p>
<p>To avoid deadlocks between range_cyclic writeback and callers that hold
pages in PageWriteback to aggregate IO until <a class="reference internal" href="#c.write_cache_pages" title="write_cache_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">write_cache_pages()</span></code></a> returns,
we do not loop back to the start of the file. Doing so causes a page
lock/page writeback access order inversion - we should only ever lock
multiple pages in ascending page-&gt;index order, and looping back to the start
of the file violates that rule and causes deadlocks.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.generic_writepages">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">generic_writepages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">writeback_control</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wbc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_writepages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>walk the list of dirty pages of the given address space and writepage() all of them.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>subtract the number of written pages from <strong>*wbc-&gt;nr_to_write</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a library function, which implements the writepages()
address_space_operation.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_write_one">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_write_one</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_write_one" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_write_one" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>write out a single folio and wait on I/O.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to write.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The folio must be locked by the caller and will be unlocked upon return.</p>
<p>Note that the mapping’s AS_EIO/AS_ENOSPC flags will be cleared when this
function returns.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_dirty_folio">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_dirty_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.filemap_dirty_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_dirty_folio" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mark a folio dirty for filesystems which do not use buffer_heads.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>Address space this folio belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio to be marked as dirty.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Filesystems which do not use buffer heads should call this function
from their set_page_dirty address space operation.  It ignores the
contents of folio_get_private(), so if the filesystem marks individual
blocks as dirty, the filesystem should handle that itself.</p>
<p>This is also sometimes used by filesystems which use buffer_heads when
a single buffer is being dirtied: we want to set the folio dirty in
that case, but not all the buffers.  This is a “bottom-up” dirtying,
whereas __set_page_dirty_buffers() is a “top-down” dirtying.</p>
<p>The caller must ensure this doesn’t race with truncation.  Most will
simply hold the folio lock, but e.g. zap_pte_range() calls with the
folio mapped and the pte lock held, which also locks out truncation.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_account_redirty">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_account_redirty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_account_redirty" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_account_redirty" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Manually account for redirtying a page.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio which is being redirtied.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Most filesystems should call <a class="reference internal" href="#c.folio_redirty_for_writepage" title="folio_redirty_for_writepage"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_redirty_for_writepage()</span></code></a> instead
of this fuction.  If your filesystem is doing writeback outside the
context of a writeback_control(), it can call this when redirtying
a folio, to de-account the dirty counters (NR_DIRTIED, WB_DIRTIED,
tsk-&gt;nr_dirtied), so that they match the written counters (NR_WRITTEN,
WB_WRITTEN) in long term. The mismatches will lead to systematic errors
in balanced_dirty_ratelimit and the dirty pages position control.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_redirty_for_writepage">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_redirty_for_writepage</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">writeback_control</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wbc</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_redirty_for_writepage" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_redirty_for_writepage" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Decline to write a dirty folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>The writeback control.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a writepage implementation decides that it doesn’t want to write
<strong>folio</strong> for some reason, it should call this function, unlock <strong>folio</strong> and
return 0.</p>
<p><strong>Return</strong></p>
<p>True if we redirtied the folio.  False if someone else dirtied
it first.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mark_dirty">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_mark_dirty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mark_dirty" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mark_dirty" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mark a folio as being modified.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For folios with a mapping this should be done under the page lock
for the benefit of asynchronous memory errors who prefer a consistent
dirty state. This rule can be broken in some special cases,
but should be better not to.</p>
<p><strong>Return</strong></p>
<p>True if the folio was newly dirtied, false if it was already dirty.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_wait_writeback">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_wait_writeback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_wait_writeback" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_writeback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for a folio to finish writeback.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to wait for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the folio is currently being written back to storage, wait for the
I/O to complete.</p>
<p><strong>Context</strong></p>
<p>Sleeps.  Must be called in process context and with
no spinlocks held.  Caller should hold a reference on the folio.
If the folio is not locked, writeback may start again after writeback
has finished.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_wait_writeback_killable">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_wait_writeback_killable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_wait_writeback_killable" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_writeback_killable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for a folio to finish writeback.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to wait for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the folio is currently being written back to storage, wait for the
I/O to complete or a fatal signal to arrive.</p>
<p><strong>Context</strong></p>
<p>Sleeps.  Must be called in process context and with
no spinlocks held.  Caller should hold a reference on the folio.
If the folio is not locked, writeback may start again after writeback
has finished.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINTR if we get a fatal signal while waiting.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_wait_stable">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_wait_stable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_wait_stable" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_stable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for writeback to finish, if necessary.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to wait on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function determines if the given folio is related to a backing
device that requires folio contents to be held stable during writeback.
If so, then it will wait for any pending writeback to complete.</p>
<p><strong>Context</strong></p>
<p>Sleeps.  Must be called in process context and with
no spinlocks held.  Caller should hold a reference on the folio.
If the folio is not locked, writeback may start again after writeback
has finished.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_inode_pages_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_inode_pages_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lstart</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lend</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>truncate range of pages specified by start &amp; end byte offsets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>mapping to truncate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt><dd><p>offset from which to truncate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt><dd><p>offset to which to truncate (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Truncate the page cache, removing the pages that are between
specified offsets (and zeroing out partial pages
if lstart or lend + 1 is not page aligned).</p>
<p>Truncate takes two passes - the first pass is nonblocking.  It will not
block on page locks and it will not block on writeback.  The second pass
will wait.  This is to prevent as much IO as possible in the affected region.
The first pass will remove most pages, so the search cost of the second pass
is low.</p>
<p>We pass down the cache-hot hint to the page freeing code.  Even if the
mapping is large, it is probably the case that the final pages are the most
recently touched, and freeing happens in ascending file offset order.</p>
<p>Note that since -&gt;invalidatepage() accepts range to invalidate
truncate_inode_pages_range is able to handle cases where lend + 1 is not
page aligned properly.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_inode_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_inode_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lstart</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>truncate <em>all</em> the pages from an offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>mapping to truncate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt><dd><p>offset from which to truncate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called under (and serialised by) inode-&gt;i_rwsem and
mapping-&gt;invalidate_lock.</p>
<p><strong>Note</strong></p>
<p>When this function returns, there can be a page in the process of
deletion (inside __delete_from_page_cache()) in the specified range.  Thus
mapping-&gt;nrpages can be non-zero when this function returns even after
truncation of the whole mapping.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_inode_pages_final">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_inode_pages_final</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages_final" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>truncate <em>all</em> pages before inode dies</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>mapping to truncate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called under (and serialized by) inode-&gt;i_rwsem.</p>
<p>Filesystems have to use this in the .evict_inode path to inform the
VM that this is the final truncate and the inode is going away.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.invalidate_mapping_pages">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">invalidate_mapping_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_mapping_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Invalidate all clean, unlocked cache of one inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space which holds the cache to invalidate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt><dd><p>the offset ‘from’ which to invalidate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt><dd><p>the offset ‘to’ which to invalidate (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes pages that are clean, unmapped and unlocked,
as well as shadow entries. It will not block on IO activity.</p>
<p>If you want to remove all the pages of one inode, regardless of
their use and writeback state, use <a class="reference internal" href="#c.truncate_inode_pages" title="truncate_inode_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">truncate_inode_pages()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>the number of the cache entries that were invalidated</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.invalidate_inode_pages2_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">invalidate_inode_pages2_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_inode_pages2_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove range of pages from an address_space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt><dd><p>the page offset ‘from’ which to invalidate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt><dd><p>the page offset ‘to’ which to invalidate (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.</p>
<p><strong>Return</strong></p>
<p>-EBUSY if any pages could not be invalidated.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.invalidate_inode_pages2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">invalidate_inode_pages2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_inode_pages2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove all pages from an address_space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.</p>
<p><strong>Return</strong></p>
<p>-EBUSY if any pages could not be invalidated.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_pagecache">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_pagecache</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.truncate_pagecache" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">newsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_pagecache" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unmap and remove pagecache that has been truncated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">newsize</span></code></dt><dd><p>new file size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>inode’s new i_size must already be written before truncate_pagecache
is called.</p>
<p>This function should typically be called before the filesystem
releases resources associated with the freed range (eg. deallocates
blocks). This way, pagecache will always stay logically coherent
with on-disk format, and the filesystem would not have to deal with
situations such as writepage being called for a page that has already
had its underlying blocks deallocated.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_setsize">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_setsize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.truncate_setsize" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">newsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_setsize" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update inode and pagecache for a new file size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">newsize</span></code></dt><dd><p>new file size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>truncate_setsize updates i_size and performs pagecache truncation (if
necessary) to <strong>newsize</strong>. It will be typically be called from the filesystem’s
setattr function when ATTR_SIZE is passed in.</p>
<p>Must be called with a lock serializing truncates and writes (generally
i_rwsem but e.g. xfs uses a different lock) and before all filesystem
specific block truncation has been performed.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.pagecache_isize_extended">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pagecache_isize_extended</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pagecache_isize_extended" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">from</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">to</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pagecache_isize_extended" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update pagecache after extension of i_size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode for which i_size was extended</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt><dd><p>original inode size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt><dd><p>new inode size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle extension of inode size either caused by extending truncate or by
write starting after current i_size. We mark the page straddling current
i_size RO so that page_mkwrite() is called on the nearest write access to
the page.  This way filesystem can be sure that page_mkwrite() is called on
the page before user writes to the page via mmap after the i_size has been
changed.</p>
<p>The function must be called after i_size is updated so that page fault
coming after we unlock the page will already see the new i_size.
The function must be called while we still hold i_rwsem - this not only
makes sure i_size is stable but also that userspace cannot observe new
i_size value before we are prepared to store mmap writes at new inode size.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_pagecache_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_pagecache_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.truncate_pagecache_range" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lstart</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lend</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_pagecache_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unmap and remove pagecache that is hole-punched</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt><dd><p>offset of beginning of hole</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt><dd><p>offset of last byte of hole</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should typically be called before the filesystem
releases resources associated with the freed range (eg. deallocates
blocks). This way, pagecache will always stay logically coherent
with on-disk format, and the filesystem would not have to deal with
situations such as writepage being called for a page that has already
had its underlying blocks deallocated.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mapping_set_error">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mapping_set_error</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">error</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mapping_set_error" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record a writeback error in the address_space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the mapping in which an error should be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">error</span></code></dt><dd><p>the error to set in the mapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When writeback fails in some way, we must record that error so that
userspace can be informed when fsync and the like are called.  We endeavor
to report errors on any file that was open at the time of the error.  Some
internal callers also need to know when writeback errors have occurred.</p>
<p>When a writeback error occurs, most filesystems will want to call
mapping_set_error to record the error in the mapping so that it can be
reported when the application calls fsync(2).</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_file_mapping">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_file_mapping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_file_mapping" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_file_mapping" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the mapping this folio belongs to.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For folios which are in the page cache, return the mapping that this
page belongs to.  Folios in the swap cache return the mapping of the
swap file or swap device where the data is stored.  This is different
from the mapping returned by <a class="reference internal" href="#c.folio_mapping" title="folio_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_mapping()</span></code></a>.  The only reason to
use it is if, like NFS, you return 0 from -&gt;activate_swapfile.</p>
<p>Do not call this for folios which aren’t in the page cache or swap cache.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_inode">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">inode</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_inode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_inode" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_inode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the host inode for this folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For folios which are in the page cache, return the inode that this folio
belongs to.</p>
<p>Do not call this for folios which aren’t in the page cache.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_attach_private">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_attach_private</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_attach_private" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_attach_private" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Attach private data to a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio to attach data to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to attach to folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attaching private data to a folio increments the page’s reference count.
The data must be detached before the folio will be freed.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_change_private">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_change_private</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_change_private" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_change_private" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Change private data on a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio to change the data on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to set on the folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Change the private data attached to a folio and return the old
data.  The page must previously have had data attached and the data
must be detached before the folio will be freed.</p>
<p><strong>Return</strong></p>
<p>Data that was previously attached to the folio.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_detach_private">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_detach_private</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_detach_private" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_detach_private" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Detach private data from a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio to detach data from.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the data that was previously attached to the folio and decrements
the refcount on the page.</p>
<p><strong>Return</strong></p>
<p>Data that was attached to the folio.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_get_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">filemap_get_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_get_folio" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find and get a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space to search.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The page index.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache entry at <strong>mapping</strong> &amp; <strong>index</strong>.  If a folio is
present, it is returned with an increased refcount.</p>
<p>Otherwise, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_get_page">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_get_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_page" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find and get a page reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt><dd><p>the page index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.  If there is a
page cache page, it is returned with an increased refcount.</p>
<p>Otherwise, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_lock_page">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_lock_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_lock_page" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>locate, pin and lock a pagecache page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>the page index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache entry at <strong>mapping</strong> &amp; <strong>index</strong>.  If there is a
page cache page, it is returned locked and with an increased
refcount.</p>
<p><strong>Context</strong></p>
<p>May sleep.</p>
<p><strong>Return</strong></p>
<p>A struct page or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is no page in the cache for this
index.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_or_create_page">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_or_create_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_or_create_page" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>locate or add a pagecache page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the page’s address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>the page’s index into the mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>page allocation mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.  If there is a
page cache page, it is returned locked and with an increased
refcount.</p>
<p>If the page is not present, a new page is allocated using <strong>gfp_mask</strong>
and added to the page cache and the VM’s LRU list.  The page is
returned locked and with an increased refcount.</p>
<p>On memory exhaustion, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
<p><a class="reference internal" href="#c.find_or_create_page" title="find_or_create_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">find_or_create_page()</span></code></a> may sleep, even if <strong>gfp_flags</strong> specifies an
atomic allocation!</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.grab_cache_page_nowait">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">grab_cache_page_nowait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.grab_cache_page_nowait" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns locked page at given index in given cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>target address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>the page index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as grab_cache_page(), but do not wait if the page is unavailable.
This is intended for speculative data generators, where the data can
be regenerated if the page couldn’t be grabbed.  This routine should
be safe to call while holding the lock for another page.</p>
<p>Clear __GFP_FS when allocating the page to avoid recursion into the fs
and deadlock against the caller’s locked page.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_index">
<span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_index</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_index" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>File index of a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For a folio which is either in the page cache or the swap cache,
return its index within the address_space it belongs to.  If you know
the page is definitely in the page cache, you can look at the folio’s
index directly.</p>
<p><strong>Return</strong></p>
<p>The index (offset in units of pages) of a folio in its file.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_next_index">
<span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_next_index</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_next_index" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_next_index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the index of the next folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The current folio.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The index of the folio which follows this folio in the file.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_file_page">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_file_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_file_page" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_file_page" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The page for a particular index.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio which contains this index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The index we want to look up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sometimes after looking up a folio in the page cache, we need to
obtain the specific page for an index (eg a page fault).</p>
<p><strong>Return</strong></p>
<p>The page containing the file data for this index.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_contains">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_contains</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_contains" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_contains" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Does this folio contain this index?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The page index within the file.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>The caller should have the page locked in order to prevent
(eg) shmem from moving the page between the page cache and swap cache
and changing its index in the middle of the operation.</p>
<p><strong>Return</strong></p>
<p>true or false.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_pos">
<span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_pos</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_pos" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_pos" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the byte position of this folio in its file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_file_pos">
<span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_file_pos</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_file_pos" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_file_pos" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the byte position of this folio in its file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This differs from <a class="reference internal" href="#c.folio_pos" title="folio_pos"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_pos()</span></code></a> for folios which belong to a swap file.
NFS is the only filesystem today which needs to use <a class="reference internal" href="#c.folio_file_pos" title="folio_file_pos"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_file_pos()</span></code></a>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.readahead_control">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_control</span></span></span><a class="headerlink" href="#c.readahead_control" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Describes a readahead request.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct readahead_control {
  struct file *file;
  struct address_space *mapping;
  struct file_ra_state *ra;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>The file, used primarily by network filesystems for authentication.
May be NULL if invoked internally by the filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mapping</span></code></dt><dd><p>Readahead this filesystem object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ra</span></code></dt><dd><p>File readahead state.  May be NULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A readahead request is for consecutive pages.  Filesystems which
implement the -&gt;readahead method should call <a class="reference internal" href="#c.readahead_page" title="readahead_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">readahead_page()</span></code></a> or
<a class="reference internal" href="#c.readahead_page_batch" title="readahead_page_batch"><code class="xref c c-func docutils literal notranslate"><span class="pre">readahead_page_batch()</span></code></a> in a loop and attempt to start I/O against
each page in the request.</p>
<p>Most of the fields in this struct are private and should be accessed
by the functions below.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_cache_sync_readahead">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_cache_sync_readahead</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.file_ra_state" title="file_ra_state"><span class="n"><span class="pre">file_ra_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ra</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_cache_sync_readahead" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">req_count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_sync_readahead" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>generic file readahead</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address_space which holds the pagecache and I/O vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_ra_state</span> <span class="pre">*ra</span></code></dt><dd><p>file_ra_state which holds the readahead state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>Used by the filesystem for authentication.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>Index of first page to be read.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">req_count</span></code></dt><dd><p>Total number of pages being read by the caller.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.page_cache_sync_readahead" title="page_cache_sync_readahead"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_cache_sync_readahead()</span></code></a> should be called when a cache miss happened:
it will submit the read.  The readahead logic may decide to piggyback more
pages onto the read request if access patterns suggest it will improve
performance.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_cache_async_readahead">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_cache_async_readahead</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.file_ra_state" title="file_ra_state"><span class="n"><span class="pre">file_ra_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ra</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_cache_async_readahead" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_cache_async_readahead" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">req_count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_async_readahead" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>file readahead for marked pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address_space which holds the pagecache and I/O vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_ra_state</span> <span class="pre">*ra</span></code></dt><dd><p>file_ra_state which holds the readahead state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>Used by the filesystem for authentication.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page at <strong>index</strong> which triggered the readahead call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>Index of first page to be read.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">req_count</span></code></dt><dd><p>Total number of pages being read by the caller.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.page_cache_async_readahead" title="page_cache_async_readahead"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_cache_async_readahead()</span></code></a> should be called when a page is used which
is marked as PageReadahead; this is a marker to suggest that the application
has used up enough of the readahead window that we should start pulling in
more pages.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_page">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">readahead_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ractl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_page" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the next page to read.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*ractl</span></code></dt><dd><p>The current readahead request.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>The page is locked and has an elevated refcount.  The caller
should decreases the refcount once the page has been submitted for I/O
and unlock the page once all I/O to that page has completed.</p>
<p><strong>Return</strong></p>
<p>A pointer to the next page, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if we are done.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">readahead_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ractl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_folio" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the next folio to read.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*ractl</span></code></dt><dd><p>The current readahead request.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>The folio is locked.  The caller should unlock the folio once
all I/O to that folio has completed.</p>
<p><strong>Return</strong></p>
<p>A pointer to the next folio, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if we are done.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.readahead_page_batch">
<span class="sig-name descname"><span class="n"><span class="pre">readahead_page_batch</span></span></span><a class="headerlink" href="#c.readahead_page_batch" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">readahead_page_batch</span> <span class="pre">(rac,</span> <span class="pre">array)</span></code></p>
<blockquote>
<div><p>Get a batch of pages to read.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rac</span></code></dt><dd><p>The current readahead request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">array</span></code></dt><dd><p>An array of pointers to struct page.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>The pages are locked and have an elevated refcount.  The caller
should decreases the refcount once the page has been submitted for I/O
and unlock the page once all I/O to that page has completed.</p>
<p><strong>Return</strong></p>
<p>The number of pages placed in the array.  0 indicates the request
is complete.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_pos">
<span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_pos</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_pos" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The byte offset into the file of this readahead request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*rac</span></code></dt><dd><p>The readahead request.</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_length">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_length</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_length" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of bytes in this readahead request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*rac</span></code></dt><dd><p>The readahead request.</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_index">
<span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_index</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The index of the first page in this readahead request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*rac</span></code></dt><dd><p>The readahead request.</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_count">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_count</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_count" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of pages in this readahead request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*rac</span></code></dt><dd><p>The readahead request.</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_batch_length">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_batch_length</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_batch_length" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of bytes in the current batch.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*rac</span></code></dt><dd><p>The readahead request.</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mkwrite_check_truncate">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_mkwrite_check_truncate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mkwrite_check_truncate" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mkwrite_check_truncate" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mkwrite_check_truncate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if folio was truncated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>the folio to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode to check the folio against</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of bytes in the folio up to EOF,
or -EFAULT if the folio was truncated.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_mkwrite_check_truncate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_mkwrite_check_truncate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_mkwrite_check_truncate" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_mkwrite_check_truncate" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_mkwrite_check_truncate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if page was truncated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the page to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode to check the page against</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes in the page up to EOF,
or -EFAULT if the page was truncated.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.i_blocks_per_folio">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i_blocks_per_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.i_blocks_per_folio" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.i_blocks_per_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.i_blocks_per_folio" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>How many blocks fit in this folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>The inode which contains the blocks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the block size is larger than the size of this folio, return zero.</p>
<p><strong>Context</strong></p>
<p>The caller should hold a refcount on the folio to prevent it
from being split.</p>
<p><strong>Return</strong></p>
<p>The number of filesystem blocks covered by this folio.</p>
</div>
<div class="section" id="memory-pools">
<h2>Memory pools<a class="headerlink" href="#memory-pools" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_exit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mempool_exit</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_exit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>exit a mempool initialized with <a class="reference internal" href="#c.mempool_init" title="mempool_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_init()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mempool_t</span> <span class="pre">*pool</span></code></dt><dd><p>pointer to the memory pool which was initialized with
<a class="reference internal" href="#c.mempool_init" title="mempool_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_init()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all reserved elements in <strong>pool</strong> and <strong>pool</strong> itself.  This function
only sleeps if the free_fn() function sleeps.</p>
<p>May be called on a zeroed but uninitialized mempool (i.e. allocated with
<a class="reference internal" href="#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a>).</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mempool_destroy</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deallocate a memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mempool_t</span> <span class="pre">*pool</span></code></dt><dd><p>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all reserved elements in <strong>pool</strong> and <strong>pool</strong> itself.  This function
only sleeps if the free_fn() function sleeps.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mempool_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min_nr</span></span>, <span class="n"><span class="pre">mempool_alloc_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">alloc_fn</span></span>, <span class="n"><span class="pre">mempool_free_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">free_fn</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize a memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mempool_t</span> <span class="pre">*pool</span></code></dt><dd><p>pointer to the memory pool that should be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_nr</span></code></dt><dd><p>the minimum number of elements guaranteed to be
allocated for this pool.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mempool_alloc_t</span> <span class="pre">*alloc_fn</span></code></dt><dd><p>user-defined element-allocation function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mempool_free_t</span> <span class="pre">*free_fn</span></code></dt><dd><p>user-defined element-freeing function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*pool_data</span></code></dt><dd><p>optional private data available to the user-defined functions.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_create()</span></code></a>, but initializes the pool in (i.e. embedded in another
structure).</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_create">
<span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mempool_create</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min_nr</span></span>, <span class="n"><span class="pre">mempool_alloc_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">alloc_fn</span></span>, <span class="n"><span class="pre">mempool_free_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">free_fn</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_nr</span></code></dt><dd><p>the minimum number of elements guaranteed to be
allocated for this pool.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mempool_alloc_t</span> <span class="pre">*alloc_fn</span></code></dt><dd><p>user-defined element-allocation function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mempool_free_t</span> <span class="pre">*free_fn</span></code></dt><dd><p>user-defined element-freeing function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*pool_data</span></code></dt><dd><p>optional private data available to the user-defined functions.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function creates and allocates a guaranteed size, preallocated
memory pool. The pool can be used from the <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_alloc()</span></code></a> and <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_free()</span></code></a>
functions. This function might sleep. Both the alloc_fn() and the free_fn()
functions might sleep - as long as the <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_alloc()</span></code></a> function is not called
from IRQ contexts.</p>
<p><strong>Return</strong></p>
<p>pointer to the created memory pool object or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_resize">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mempool_resize</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new_min_nr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_resize" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>resize an existing memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mempool_t</span> <span class="pre">*pool</span></code></dt><dd><p>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_create()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new_min_nr</span></code></dt><dd><p>the new minimum number of elements guaranteed to be
allocated for this pool.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function shrinks/grows the pool. In the case of growing,
it cannot be guaranteed that the pool will be grown to the new
size immediately, but new <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_free()</span></code></a> calls will refill it.
This function may sleep.</p>
<p>Note, the caller must guarantee that no mempool_destroy is called
while this function is running. <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_alloc()</span></code></a> &amp; <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_free()</span></code></a>
might be called (eg. from IRQ contexts) while this function executes.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_alloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mempool_alloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate an element from a specific memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mempool_t</span> <span class="pre">*pool</span></code></dt><dd><p>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_create()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>the usual allocation bitmask.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function only sleeps if the alloc_fn() function sleeps or
returns NULL. Note that due to preallocation, this function
<em>never</em> fails when called from process contexts. (it might
fail if called from an IRQ context.)</p>
<p><strong>Note</strong></p>
<p>using __GFP_ZERO is not supported.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated element or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mempool_free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">element</span></span>, <span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return an element to the pool.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*element</span></code></dt><dd><p>pool element pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mempool_t</span> <span class="pre">*pool</span></code></dt><dd><p>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function only sleeps if the free_fn() function sleeps.</p>
</div>
<div class="section" id="dma-pools">
<h2>DMA pools<a class="headerlink" href="#dma-pools" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_pool_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_pool_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">boundary</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates a pool of consistent memory blocks, for dma.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of pool, for diagnostics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device that will be doing the DMA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the blocks in this pool.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment requirement for blocks; must be a power of two</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">boundary</span></code></dt><dd><p>returned blocks won’t cross this power of two boundary</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>not in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Given one of these pools, <a class="reference internal" href="#c.dma_pool_alloc" title="dma_pool_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_pool_alloc()</span></code></a>
may be used to allocate memory.  Such memory will all have “consistent”
DMA mappings, accessible by the device and its driver without using
cache flushing primitives.  The actual size of blocks allocated may be
larger than requested because of alignment.</p>
<p>If <strong>boundary</strong> is nonzero, objects returned from <a class="reference internal" href="#c.dma_pool_alloc" title="dma_pool_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_pool_alloc()</span></code></a> won’t
cross that size boundary.  This is useful for devices which have
addressing restrictions on individual DMA transfers, such as not crossing
boundaries of 4KBytes.</p>
<p><strong>Return</strong></p>
<p>a dma allocation pool with the requested characteristics, or
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if one can’t be created.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_pool_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_pool_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>destroys a pool of dma memory blocks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*pool</span></code></dt><dd><p>dma pool that will be destroyed</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Caller guarantees that no more memory from the pool is in use,
and that nothing will try to use the pool after this call.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_pool_alloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_pool_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mem_flags</span></span>, <span class="n"><span class="pre">dma_addr_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get a block of consistent memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*pool</span></code></dt><dd><p>dma pool that will produce the block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">mem_flags</span></code></dt><dd><p>GFP_* bitmask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*handle</span></code></dt><dd><p>pointer to dma address of block</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the kernel virtual address of a currently unused block,
and reports its dma address through the handle.
If such a memory block can’t be allocated, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_pool_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_pool_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vaddr</span></span>, <span class="n"><span class="pre">dma_addr_t</span></span><span class="w"> </span><span class="n"><span class="pre">dma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>put block back into dma pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*pool</span></code></dt><dd><p>the dma pool holding the block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*vaddr</span></code></dt><dd><p>virtual address of block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">dma</span></code></dt><dd><p>dma address of block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller promises neither device nor driver will again touch this block
unless it is first re-allocated.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dmam_pool_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dmam_pool_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">allocation</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_pool_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Managed <a class="reference internal" href="#c.dma_pool_create" title="dma_pool_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_pool_create()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of pool, for diagnostics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device that will be doing the DMA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the blocks in this pool.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment requirement for blocks; must be a power of two</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">allocation</span></code></dt><dd><p>returned blocks won’t cross this boundary (or zero)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.dma_pool_create" title="dma_pool_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_pool_create()</span></code></a>.  DMA pool created with this function is
automatically destroyed on driver detach.</p>
<p><strong>Return</strong></p>
<p>a managed dma allocation pool with the requested
characteristics, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if one can’t be created.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dmam_pool_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dmam_pool_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_pool_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Managed <a class="reference internal" href="#c.dma_pool_destroy" title="dma_pool_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_pool_destroy()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*pool</span></code></dt><dd><p>dma pool that will be destroyed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.dma_pool_destroy" title="dma_pool_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_pool_destroy()</span></code></a>.</p>
</div>
<div class="section" id="more-memory-management-functions">
<h2>More Memory Management Functions<a class="headerlink" href="#more-memory-management-functions" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.zap_vma_ptes">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">zap_vma_ptes</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">address</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zap_vma_ptes" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove ptes mapping the vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>vm_area_struct holding ptes to be zapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt><dd><p>starting address of pages to zap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>number of bytes to zap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function only unmaps ptes assigned to VM_PFNMAP vmas.</p>
<p>The entire address range must be fully contained within the vma.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_insert_pages">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_insert_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>insert multiple pages into user vma, batching the pmd lock.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target start user address of these pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>source kernel pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*num</span></code></dt><dd><p>in: number of pages to map. out: number of pages that were <em>not</em>
mapped. (0 means all pages were successfully mapped).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Preferred over <a class="reference internal" href="#c.vm_insert_page" title="vm_insert_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">vm_insert_page()</span></code></a> when inserting multiple pages.</p>
<p>In case of error, we may have mapped a subset of the provided
pages. It is the caller’s responsibility to account for this case.</p>
<p>The same restrictions apply as in <a class="reference internal" href="#c.vm_insert_page" title="vm_insert_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">vm_insert_page()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_insert_page">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_insert_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.vm_insert_page" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_page" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>insert single page into user vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target user address of this page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>source kernel page</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allows drivers to insert individual pages they’ve allocated
into a user vma.</p>
<p>The page has to be a nice clean _individual_ kernel allocation.
If you allocate a compound page, you need to have marked it as
such (__GFP_COMP), or manually just split the page up yourself
(see split_page()).</p>
<p>NOTE! Traditionally this was done with “<a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">remap_pfn_range()</span></code></a>” which
took an arbitrary page protection parameter. This doesn’t allow
that. Your vma protection will have to be set up correctly, which
means that if you want a shared writable mapping, you’d better
ask for a shared writable mapping!</p>
<p>The page does not need to be reserved.</p>
<p>Usually this function is called from f_op-&gt;mmap() handler
under mm-&gt;mmap_lock write-lock, so it can change vma-&gt;vm_flags.
Caller must set VM_MIXEDMAP on vma if it wants to call this
function from other places, for example from page-fault handler.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_map_pages">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_map_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_map_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>maps range of kernel pages starts with non zero offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>pointer to array of source kernel pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">num</span></code></dt><dd><p>number of pages in page array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps an object consisting of <strong>num</strong> pages, catering for the user’s
requested vm_pgoff</p>
<p>If we fail to insert any page into the vma, the function will return
immediately leaving any previously inserted pages present.  Callers
from the mmap handler may immediately return the error as their caller
will destroy the vma, removing any successfully inserted pages. Other
callers should make their own arrangements for calling unmap_region().</p>
<p><strong>Context</strong></p>
<p>Process context. Called by mmap handlers.</p>
<p><strong>Return</strong></p>
<p>0 on success and error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_map_pages_zero">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_map_pages_zero</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_map_pages_zero" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map range of kernel pages starts with zero offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>pointer to array of source kernel pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">num</span></code></dt><dd><p>number of pages in page array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.vm_map_pages" title="vm_map_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">vm_map_pages()</span></code></a>, except that it explicitly sets the offset
to 0. This function is intended for the drivers that did not consider
vm_pgoff.</p>
<p><strong>Context</strong></p>
<p>Process context. Called by mmap handlers.</p>
<p><strong>Return</strong></p>
<p>0 on success and error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmf_insert_pfn_prot">
<a class="reference internal" href="#c.vm_fault_t" title="vm_fault_t"><span class="n"><span class="pre">vm_fault_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vmf_insert_pfn_prot</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="n"><span class="pre">pgprot_t</span></span><span class="w"> </span><span class="n"><span class="pre">pgprot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmf_insert_pfn_prot" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>insert single pfn into user vma with specified pgprot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target user address of this page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>source kernel pfn</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgprot_t</span> <span class="pre">pgprot</span></code></dt><dd><p>pgprot flags for the inserted page</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is exactly like <a class="reference internal" href="#c.vmf_insert_pfn" title="vmf_insert_pfn"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmf_insert_pfn()</span></code></a>, except that it allows drivers
to override pgprot on a per-page basis.</p>
<p>This only makes sense for IO mappings, and it makes no sense for
COW mappings.  In general, using multiple vmas is preferable;
vmf_insert_pfn_prot should only be used if using multiple VMAs is
impractical.</p>
<p>See <a class="reference internal" href="#c.vmf_insert_mixed_prot" title="vmf_insert_mixed_prot"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmf_insert_mixed_prot()</span></code></a> for a discussion of the implication of using
a value of <strong>pgprot</strong> different from that of <strong>vma-&gt;vm_page_prot</strong>.</p>
<p><strong>Context</strong></p>
<p>Process context.  May allocate using <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>.</p>
<p><strong>Return</strong></p>
<p>vm_fault_t value.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmf_insert_pfn">
<a class="reference internal" href="#c.vm_fault_t" title="vm_fault_t"><span class="n"><span class="pre">vm_fault_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vmf_insert_pfn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmf_insert_pfn" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>insert single pfn into user vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target user address of this page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>source kernel pfn</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to vm_insert_page, this allows drivers to insert individual pages
they’ve allocated into a user vma. Same comments apply.</p>
<p>This function should only be called from a vm_ops-&gt;fault handler, and
in that case the handler should return the result of this function.</p>
<p>vma cannot be a COW mapping.</p>
<p>As this is called only for pages that do not currently exist, we
do not need to flush old virtual caches or the TLB.</p>
<p><strong>Context</strong></p>
<p>Process context.  May allocate using <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>.</p>
<p><strong>Return</strong></p>
<p>vm_fault_t value.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmf_insert_mixed_prot">
<a class="reference internal" href="#c.vm_fault_t" title="vm_fault_t"><span class="n"><span class="pre">vm_fault_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vmf_insert_mixed_prot</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">pfn_t</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="n"><span class="pre">pgprot_t</span></span><span class="w"> </span><span class="n"><span class="pre">pgprot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmf_insert_mixed_prot" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>insert single pfn into user vma with specified pgprot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target user address of this page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pfn_t</span> <span class="pre">pfn</span></code></dt><dd><p>source kernel pfn</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgprot_t</span> <span class="pre">pgprot</span></code></dt><dd><p>pgprot flags for the inserted page</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is exactly like vmf_insert_mixed(), except that it allows drivers
to override pgprot on a per-page basis.</p>
<p>Typically this function should be used by drivers to set caching- and
encryption bits different than those of <strong>vma-&gt;vm_page_prot</strong>, because
the caching- or encryption mode may not be known at mmap() time.
This is ok as long as <strong>vma-&gt;vm_page_prot</strong> is not used by the core vm
to set caching and encryption bits for those vmas (except for COW pages).
This is ensured by core vm only modifying these page table entries using
functions that don’t touch caching- or encryption bits, using pte_modify()
if needed. (See for example mprotect()).
Also when new page-table entries are created, this is only done using the
fault() callback, and never using the value of vma-&gt;vm_page_prot,
except for page-table entries that point to anonymous pages as the result
of COW.</p>
<p><strong>Context</strong></p>
<p>Process context.  May allocate using <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>.</p>
<p><strong>Return</strong></p>
<p>vm_fault_t value.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.remap_pfn_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">remap_pfn_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">pgprot_t</span></span><span class="w"> </span><span class="n"><span class="pre">prot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_pfn_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remap kernel memory to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target page aligned user address to start at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>page frame number of kernel physical memory address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>size of mapping area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt><dd><p>page protection flags for this mapping</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>this is only safe if the mm semaphore is held when called.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_iomap_memory">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_iomap_memory</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="n"><span class="pre">phys_addr_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_iomap_memory" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remap memory to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phys_addr_t</span> <span class="pre">start</span></code></dt><dd><p>start of the physical memory to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">len</span></code></dt><dd><p>size of area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simplified io_remap_pfn_range() for common driver use. The
driver just needs to give us the physical memory range to be mapped,
we’ll figure out the rest from the vma information.</p>
<p>NOTE! Some drivers might want to tweak vma-&gt;vm_page_prot first to get
whatever write-combining details or similar.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.unmap_mapping_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unmap_mapping_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">even_cows</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_mapping_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unmap pages from processes.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address space containing pages to be unmapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt><dd><p>Index of first page to be unmapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">nr</span></code></dt><dd><p>Number of pages to be unmapped.  0 to unmap to end of file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">even_cows</span></code></dt><dd><p>Whether to unmap even private COWed pages.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmap the pages in this address space from any userspace process which
has them mmaped.  Generally, you want to remove COWed pages as well when
a file is being truncated, but not when invalidating pages from the page
cache.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.unmap_mapping_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unmap_mapping_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">holebegin</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">holelen</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">even_cows</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_mapping_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unmap the portion of all mmaps in the specified address_space corresponding to the specified byte range in the underlying file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address space containing mmaps to be unmapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">const</span> <span class="pre">holebegin</span></code></dt><dd><p>byte in first page to unmap, relative to the start of
the underlying file.  This will be rounded down to a PAGE_SIZE
boundary.  Note that this is different from <a class="reference internal" href="#c.truncate_pagecache" title="truncate_pagecache"><code class="xref c c-func docutils literal notranslate"><span class="pre">truncate_pagecache()</span></code></a>, which
must keep the partial page.  In contrast, we must get rid of
partial pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">const</span> <span class="pre">holelen</span></code></dt><dd><p>size of prospective hole in bytes.  This will be rounded
up to a PAGE_SIZE boundary.  A holelen of zero truncates to the
end of the file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">even_cows</span></code></dt><dd><p>1 when truncating a file, unmap even private COWed pages;
but 0 when invalidating pagecache, don’t throw away private data.</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.follow_pte">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">follow_pte</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">address</span></span>, <span class="n"><span class="pre">pte_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptepp</span></span>, <span class="n"><span class="pre">spinlock_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptlp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.follow_pte" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>look up PTE at a user virtual address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>the mm_struct of the target address space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt><dd><p>user virtual address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pte_t</span> <span class="pre">**ptepp</span></code></dt><dd><p>location to store found PTE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">**ptlp</span></code></dt><dd><p>location to store the lock for the PTE</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>On a successful return, the pointer to the PTE is stored in <strong>ptepp</strong>;
the corresponding lock is taken and its location is stored in <strong>ptlp</strong>.
The contents of the PTE are only stable until <strong>ptlp</strong> is released;
any further use, if any, must be protected against invalidation
with MMU notifiers.</p>
<p>Only IO mappings and raw PFN mappings are allowed.  The mmap semaphore
should be taken for read.</p>
<p>KVM uses this function.  While it is arguably less bad than <code class="docutils literal notranslate"><span class="pre">follow_pfn</span></code>,
it is not a good general-purpose API.</p>
<p><strong>Return</strong></p>
<p>zero on success, -ve otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.follow_pfn">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">follow_pfn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">address</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pfn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.follow_pfn" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>look up PFN at a user virtual address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>memory mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt><dd><p>user virtual address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*pfn</span></code></dt><dd><p>location to store found PFN</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only IO mappings and raw PFN mappings are allowed.</p>
<p>This function does not allow the caller to read the permissions
of the PTE.  Do not use it.</p>
<p><strong>Return</strong></p>
<p>zero and the pfn at <strong>pfn</strong> on success, -ve otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.generic_access_phys">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">generic_access_phys</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">write</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_access_phys" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>generic implementation for iomem mmap access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>the vma to access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>userspace address, not relative offset within <strong>vma</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to read/write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p>set to FOLL_WRITE when writing, otherwise reading</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a generic implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">vm_operations_struct.access</span></code> for an
iomem mapping. This callback is used by access_process_vm() when the <strong>vma</strong> is
not page based.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_pfnblock_flags_mask">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_pfnblock_flags_mask</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.get_pfnblock_flags_mask" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_pfnblock_flags_mask" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the requested group of flags for the pageblock_nr_pages block of pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page within the block of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>The target page frame number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>mask of bits that the caller is interested in</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>pageblock_bits flags</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_pfnblock_flags_mask">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_pfnblock_flags_mask</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.set_pfnblock_flags_mask" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_pfnblock_flags_mask" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the requested group of flags for a pageblock_nr_pages block of pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page within the block of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>The flags to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>The target page frame number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>mask of bits that the caller is interested in</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.__putback_isolated_page">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__putback_isolated_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__putback_isolated_page" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__putback_isolated_page" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a now-isolated page back where we got it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>Page that was isolated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Order of the isolated page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mt</span></code></dt><dd><p>The page’s pageblock’s migratetype</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is meant to return a page pulled from the free lists via
__isolate_free_page back to the free lists they were pulled from.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.__free_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__free_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__free_pages" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__free_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free pages allocated with <a class="reference internal" href="#c.alloc_pages" title="alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages()</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page pointer returned from <a class="reference internal" href="#c.alloc_pages" title="alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>The order of the allocation.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can free multi-page allocations that are not compound
pages.  It does not check that the <strong>order</strong> passed in matches that of
the allocation, so it is easy to leak memory.  Freeing more memory
than was allocated will probably emit a warning.</p>
<p>If the last reference to this page is speculative, it will be released
by put_page() which only frees the first page of a non-compound
allocation.  To prevent the remaining pages from being leaked, we free
the subsequent pages here.  If you want to use the page’s reference
count to decide when to free the allocation, you should allocate a
compound page, and use put_page() instead of <a class="reference internal" href="#c.__free_pages" title="__free_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">__free_pages()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>May be called in interrupt context or while holding a normal
spinlock, but not in NMI context or while holding a raw spinlock.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_pages_exact">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_pages_exact</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages_exact" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate an exact number physically-contiguous pages.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the number of bytes to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>GFP flags for the allocation, must not contain __GFP_COMP</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar to <a class="reference internal" href="#c.alloc_pages" title="alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages()</span></code></a>, except that it allocates the
minimum number of pages to satisfy the request.  <a class="reference internal" href="#c.alloc_pages" title="alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages()</span></code></a> can only
allocate memory in power-of-two pages.</p>
<p>This function is also limited by MAX_ORDER.</p>
<p>Memory allocated by this function must be released by <a class="reference internal" href="#c.free_pages_exact" title="free_pages_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_pages_exact()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated area or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_pages_exact_nid">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_pages_exact_nid</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages_exact_nid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate an exact number of physically-contiguous pages on a node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>the preferred node ID where memory should be allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the number of bytes to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>GFP flags for the allocation, must not contain __GFP_COMP</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.alloc_pages_exact" title="alloc_pages_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages_exact()</span></code></a>, but try to allocate on node nid first before falling
back.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated area or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.free_pages_exact">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">free_pages_exact</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">virt</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.free_pages_exact" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release memory allocated via <a class="reference internal" href="#c.alloc_pages_exact" title="alloc_pages_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages_exact()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*virt</span></code></dt><dd><p>the value returned by alloc_pages_exact.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of allocation, same value as passed to <a class="reference internal" href="#c.alloc_pages_exact" title="alloc_pages_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages_exact()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release the memory allocated by a previous call to alloc_pages_exact.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.nr_free_zone_pages">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nr_free_zone_pages</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.nr_free_zone_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>count number of pages beyond high watermark</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>The zone index of the highest zone</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.nr_free_zone_pages" title="nr_free_zone_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">nr_free_zone_pages()</span></code></a> counts the number of pages which are beyond the
high watermark within all zones at or below a given zone index.  For each
zone, the number of pages is calculated as:</p>
<blockquote>
<div><p>nr_free_zone_pages = managed_pages - high_pages</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>number of pages beyond high watermark.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.nr_free_buffer_pages">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nr_free_buffer_pages</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.nr_free_buffer_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>count number of pages beyond high watermark</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.nr_free_buffer_pages" title="nr_free_buffer_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">nr_free_buffer_pages()</span></code></a> counts the number of pages which are beyond the high
watermark within ZONE_DMA and ZONE_NORMAL.</p>
<p><strong>Return</strong></p>
<p>number of pages beyond high watermark within ZONE_DMA and
ZONE_NORMAL.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_next_best_node">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_next_best_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="n"><span class="pre">nodemask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">used_node_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_next_best_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the next node that should appear in a given node’s fallback list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>node whose fallback list we’re appending</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodemask_t</span> <span class="pre">*used_node_mask</span></code></dt><dd><p>nodemask_t of already used nodes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We use a number of factors to determine which is the next node that should
appear on a given node’s fallback list.  The node should not have appeared
already in <strong>node</strong>’s fallback list, and it should be the next closest node
according to the distance array (which contains arbitrary distance values
from each node to each node in the system), and should also prefer nodes
with no CPUs, since presumably they’ll have very little allocation pressure
on them otherwise.</p>
<p><strong>Return</strong></p>
<p>node id of the found node or <code class="docutils literal notranslate"><span class="pre">NUMA_NO_NODE</span></code> if no node is found.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_pfn_range_for_nid">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_pfn_range_for_nid</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start_pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">end_pfn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_pfn_range_for_nid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the start and end page frames for a node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>The nid to return the range for. If MAX_NUMNODES, the min and max PFN are returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*start_pfn</span></code></dt><dd><p>Passed by reference. On return, it will have the node start_pfn.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*end_pfn</span></code></dt><dd><p>Passed by reference. On return, it will have the node end_pfn.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns the start and end page frame of a node based on information
provided by <a class="reference internal" href="boot-time-mm.html#c.memblock_set_node" title="memblock_set_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">memblock_set_node()</span></code></a>. If called for a node
with no available memory, a warning is printed and the start and end
PFNs will be 0.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.absent_pages_in_range">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">absent_pages_in_range</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start_pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">end_pfn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.absent_pages_in_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return number of page frames in holes within a range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start_pfn</span></code></dt><dd><p>The start PFN to start searching for holes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_pfn</span></code></dt><dd><p>The end PFN to stop searching for holes</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of pages frames in memory holes within a range.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.node_map_pfn_alignment">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">node_map_pfn_alignment</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.node_map_pfn_alignment" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>determine the maximum internode alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called after node map is populated and sorted.
It calculates the maximum power of two alignment which can distinguish
all the nodes.</p>
<p>For example, if all nodes are 1GiB and aligned to 1GiB, the return value
would indicate 1GiB alignment with (1 &lt;&lt; (30 - PAGE_SHIFT)).  If the
nodes are shifted by 256MiB, 256MiB.  Note that if only the last node is
shifted, 1GiB is enough and this function will indicate so.</p>
<p>This is used to test whether pfn -&gt; nid mapping of the chosen memory
model has fine enough granularity to avoid incorrect mapping for the
populated node map.</p>
<p><strong>Return</strong></p>
<p>the determined alignment in pfn’s.  0 if there is no alignment
requirement (single node).</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_min_pfn_with_active_regions">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_min_pfn_with_active_regions</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_min_pfn_with_active_regions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the minimum PFN registered</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the minimum PFN based on information provided via
<a class="reference internal" href="boot-time-mm.html#c.memblock_set_node" title="memblock_set_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">memblock_set_node()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.free_area_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">free_area_init</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">max_zone_pfn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.free_area_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialise all pg_data_t and zone data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*max_zone_pfn</span></code></dt><dd><p>an array of max PFNs for each zone</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will call free_area_init_node() for each active node in the system.
Using the page ranges provided by <a class="reference internal" href="boot-time-mm.html#c.memblock_set_node" title="memblock_set_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">memblock_set_node()</span></code></a>, the size of each
zone in each node and their holes is calculated. If the maximum PFN
between two adjacent zones match, it is assumed that the zone is empty.
For example, if arch_max_dma_pfn == arch_max_dma32_pfn, it is assumed
that arch_max_dma32_pfn has no pages. It is also assumed that a zone
starts where the previous one ended. For example, ZONE_DMA32 starts
at arch_max_dma_pfn.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_dma_reserve">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_dma_reserve</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new_dma_reserve</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_dma_reserve" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the specified number of pages reserved in the first zone</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">new_dma_reserve</span></code></dt><dd><p>The number of pages to mark reserved</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The per-cpu batchsize and zone watermarks are determined by managed_pages.
In the DMA zone, a significant percentage may be consumed by kernel image
and other unfreeable allocations which can skew the watermarks badly. This
function may optionally be used to account for unfreeable pages in the
first zone (e.g., ZONE_DMA). The effect will be lower watermarks and
smaller per-cpu batchsize.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.setup_per_zone_wmarks">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">setup_per_zone_wmarks</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.setup_per_zone_wmarks" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>called when min_free_kbytes changes or when memory is hot-{added|removed}</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ensures that the watermark[min,low,high] values for each zone are set
correctly with respect to min_free_kbytes.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_contig_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">alloc_contig_range</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">migratetype</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_contig_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>tries to allocate given range of pages</p></li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>start PFN to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt><dd><p>one-past-the-last PFN to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">migratetype</span></code></dt><dd><p>migratetype of the underlying pageblocks (either
#MIGRATE_MOVABLE or #MIGRATE_CMA).  All pageblocks
in range must have the same migratetype and it must
be either of the two.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>GFP mask to use during compaction</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The PFN range does not have to be pageblock or MAX_ORDER_NR_PAGES
aligned.  The PFN range must belong to a single zone.</p>
<p>The first thing this routine does is attempt to MIGRATE_ISOLATE all
pageblocks in the range.  Once isolated, the pageblocks should not
be modified by others.</p>
<p><strong>Return</strong></p>
<p>zero on success or negative error code.  On success all
pages which PFN is in [start, end) are allocated for the caller and
need to be freed with free_contig_range().</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_contig_pages">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_contig_pages</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span>, <span class="n"><span class="pre">nodemask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nodemask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_contig_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>tries to find and allocate contiguous range of pages</p></li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr_pages</span></code></dt><dd><p>Number of contiguous pages to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>GFP mask to limit search and used during compaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>Target node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodemask_t</span> <span class="pre">*nodemask</span></code></dt><dd><p>Mask for other possible nodes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is a wrapper around <a class="reference internal" href="#c.alloc_contig_range" title="alloc_contig_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_contig_range()</span></code></a>. It scans over zones
on an applicable zonelist to find a contiguous pfn range which can then be
tried for allocation with <a class="reference internal" href="#c.alloc_contig_range" title="alloc_contig_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_contig_range()</span></code></a>. This routine is intended
for allocation requests which can not be fulfilled with the buddy allocator.</p>
<p>The allocated memory is always aligned to a page boundary. If nr_pages is a
power of two then the alignment is guaranteed to be to the given nr_pages
(e.g. 1GB request would be aligned to 1GB).</p>
<p>Allocated pages can be freed with free_contig_range() or by manually calling
__free_page() on each allocated page.</p>
<p><strong>Return</strong></p>
<p>pointer to contiguous pages on success, or NULL if not successful.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.numa_map_to_online_node">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numa_map_to_online_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.numa_map_to_online_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find closest online node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>Node id to start the search</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lookup the next closest node by distance if <strong>nid</strong> is not online.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_pages_vma">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_pages_vma</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">hugepage</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages_vma" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a page for a VMA.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Order of the GFP allocation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>Pointer to VMA or NULL if not available.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>Virtual address of the allocation.  Must be inside <strong>vma</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>Which node to prefer for allocation (modulo policy).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">hugepage</span></code></dt><dd><p>For hugepages try only the preferred node if possible.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a page for a specific address in <strong>vma</strong>, using the appropriate
NUMA policy.  When <strong>vma</strong> is not NULL the caller must hold the mmap_lock
of the mm_struct of the VMA to prevent it from going away.  Should be
used for all allocations for pages that will be mapped into user space.</p>
<p><strong>Return</strong></p>
<p>The page on success or NULL if allocation fails.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_pages">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_pages</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gfp_t" title="gfp_t"><span class="n"><span class="pre">gfp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate pages.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">order</span></code></dt><dd><p>Power of two of number of pages to allocate.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate 1 &lt;&lt; <strong>order</strong> contiguous pages.  The physical address of the
first page is naturally aligned (eg an order-3 allocation will be aligned
to a multiple of 8 * PAGE_SIZE bytes).  The NUMA policy of the current
process is honoured when in process context.</p>
<p><strong>Context</strong></p>
<p>Can be called from any context, providing the appropriate GFP
flags are used.</p>
<p><strong>Return</strong></p>
<p>The page on success or NULL if allocation fails.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpol_misplaced">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpol_misplaced</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.mpol_misplaced" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpol_misplaced" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check whether current page node is valid in policy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page to be checked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>vm area where page mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>virtual address where page mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lookup current policy node id for vma,addr and “compare to” page’s
node id.  Policy determination “mimics” alloc_page_vma().
Called from fault path where we know the vma and faulting address.</p>
<p><strong>Return</strong></p>
<p>NUMA_NO_NODE if the page is in a node that is valid for this
policy, or a suitable node ID to allocate a replacement page from.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpol_shared_policy_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpol_shared_policy_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">shared_policy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mempolicy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mpol</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpol_shared_policy_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize shared policy for inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">shared_policy</span> <span class="pre">*sp</span></code></dt><dd><p>pointer to inode shared policy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mempolicy</span> <span class="pre">*mpol</span></code></dt><dd><p>struct mempolicy to install</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Install non-NULL <strong>mpol</strong> in inode’s shared policy rb-tree.
On entry, the current task has a reference on a non-NULL <strong>mpol</strong>.
This must be released on exit.
This is called at get_inode() calls and we can use GFP_KERNEL.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpol_parse_str">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpol_parse_str</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mempolicy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mpol</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpol_parse_str" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>parse string to mempolicy, for tmpfs mpol mount option.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*str</span></code></dt><dd><p>string containing mempolicy to parse</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mempolicy</span> <span class="pre">**mpol</span></code></dt><dd><p>pointer to struct mempolicy pointer, returned on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Format of input:</dt><dd><p>&lt;mode&gt;[=&lt;flags&gt;][:&lt;nodelist&gt;]</p>
</dd>
</dl>
<p>On success, returns 0, else 1</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpol_to_str">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpol_to_str</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">maxlen</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mempolicy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pol</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpol_to_str" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>format a mempolicy structure for printing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buffer</span></code></dt><dd><p>to contain formatted mempolicy string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">maxlen</span></code></dt><dd><p>length of <strong>buffer</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mempolicy</span> <span class="pre">*pol</span></code></dt><dd><p>pointer to mempolicy to be formatted</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convert <strong>pol</strong> into a string.  If <strong>buffer</strong> is too short, truncate the string.
Recommend a <strong>maxlen</strong> of at least 32 for the longest mode, “interleave”, the
longest flag, “relative”, and to display at least a few node ids.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio</span></span></span><a class="headerlink" href="#c.folio" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Represents a contiguous set of bytes.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct folio {
  unsigned long flags;
  struct list_head lru;
  struct address_space *mapping;
  pgoff_t index;
  void *private;
  atomic_t _mapcount;
  atomic_t _refcount;
#ifdef CONFIG_MEMCG;
  unsigned long memcg_data;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Identical to the page flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lru</span></code></dt><dd><p>Least Recently Used list; tracks how recently this folio was used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mapping</span></code></dt><dd><p>The file this page belongs to, or refers to the anon_vma for
anonymous memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Offset within the file, in units of pages.  For anonymous memory,
this is the index from the beginning of the mmap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt><dd><p>Filesystem per-folio data (see <a class="reference internal" href="#c.folio_attach_private" title="folio_attach_private"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_attach_private()</span></code></a>).
Used for swp_entry_t if folio_test_swapcache().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mapcount</span></code></dt><dd><p>Do not access this member directly.  Use folio_mapcount() to
find out how many times this folio is mapped by userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_refcount</span></code></dt><dd><p>Do not access this member directly.  Use <a class="reference internal" href="#c.folio_ref_count" title="folio_ref_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_ref_count()</span></code></a>
to find how many references there are to this folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memcg_data</span></code></dt><dd><p>Memory Control Group data.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A folio is a physically, virtually and logically contiguous set
of bytes.  It is a power-of-two in size, and it is aligned to that
same power-of-two.  It is at least as large as <code class="docutils literal notranslate"><span class="pre">PAGE_SIZE</span></code>.  If it is
in the page cache, it is at a file offset which is a multiple of that
power-of-two.  It may be mapped into userspace at an address which is
at an arbitrary page offset, but its kernel virtual address is aligned
to its size.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.vm_fault_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_fault_t</span></span></span><a class="headerlink" href="#c.vm_fault_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return type for page fault handlers.</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>Page fault handlers return a bitmask of <code class="docutils literal notranslate"><span class="pre">VM_FAULT</span></code> values.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.vm_fault_reason">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_fault_reason</span></span></span><a class="headerlink" href="#c.vm_fault_reason" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Page fault handlers return a bitmask of these values to tell the core VM what happened when handling the fault. Used to decide whether a process gets delivered SIGBUS or just gets major/minor fault counters bumped up.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_OOM</span></code></dt><dd><p>Out Of Memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_SIGBUS</span></code></dt><dd><p>Bad access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_MAJOR</span></code></dt><dd><p>Page read from storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_WRITE</span></code></dt><dd><p>Special case for get_user_pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_HWPOISON</span></code></dt><dd><p>Hit poisoned small page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_HWPOISON_LARGE</span></code></dt><dd><p>Hit poisoned large page. Index encoded
in upper bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_SIGSEGV</span></code></dt><dd><p>segmentation fault</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_NOPAGE</span></code></dt><dd><p>-&gt;fault installed the pte, not return page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_LOCKED</span></code></dt><dd><p>-&gt;fault locked the returned page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_RETRY</span></code></dt><dd><p>-&gt;fault blocked, must retry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_FALLBACK</span></code></dt><dd><p>huge page fault failed, fall back to small</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_DONE_COW</span></code></dt><dd><p>-&gt;fault has fully handled COW</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_NEEDDSYNC</span></code></dt><dd><p>-&gt;fault did not modify page tables and needs
fsync() to complete (for synchronous page faults
in DAX)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_HINDEX_MASK</span></code></dt><dd><p>mask HINDEX value</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_is_file_lru">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_is_file_lru</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_is_file_lru" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_is_file_lru" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Should the folio be on a file LRU or anon LRU?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to test.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We would like to get this info without a page flag, but the state
needs to survive until the folio is last deleted from the LRU, which
could be as far down as __page_cache_release.</p>
<p><strong>Return</strong></p>
<p>An integer (not a boolean!) used to sort a folio onto the
right LRU list and to account folios correctly.
1 if <strong>folio</strong> is a regular filesystem backed page cache folio
or a lazily freed anonymous folio (e.g. via MADV_FREE).
0 if <strong>folio</strong> is a normal anonymous folio, a tmpfs folio or otherwise
ram or swap backed folio.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.__folio_clear_lru_flags">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__folio_clear_lru_flags</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__folio_clear_lru_flags" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__folio_clear_lru_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear page lru flags before releasing a page.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio that was on lru and now has a zero reference.</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_lru_list">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">lru_list</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_lru_list</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_lru_list" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_lru_list" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Which LRU list should a folio be on?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to test.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The LRU list a folio should be on, as an index
into the array of LRU lists.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.page_folio">
<span class="sig-name descname"><span class="n"><span class="pre">page_folio</span></span></span><a class="headerlink" href="#c.page_folio" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">page_folio</span> <span class="pre">(p)</span></code></p>
<blockquote>
<div><p>Converts from page to folio.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The page.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Every page is part of a folio.  This function cannot be called on a
NULL pointer.</p>
<p><strong>Context</strong></p>
<p>No reference, nor lock is required on <strong>page</strong>.  If the caller
does not hold a reference, this call may race with a folio split, so
it should re-check the folio still contains this page after gaining
a reference on the folio.</p>
<p><strong>Return</strong></p>
<p>The folio which contains this page.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.folio_page">
<span class="sig-name descname"><span class="n"><span class="pre">folio_page</span></span></span><a class="headerlink" href="#c.folio_page" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">folio_page</span> <span class="pre">(folio,</span> <span class="pre">n)</span></code></p>
<blockquote>
<div><p>Return a page from a folio.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">folio</span></code></dt><dd><p>The folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>The page number to return.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>n</strong> is relative to the start of the folio.  This function does not
check that the page number lies within <strong>folio</strong>; the caller is presumed
to have a reference to the page.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_has_private">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_has_private</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_has_private" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_has_private" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if page has private stuff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if a page has private stuff, indicating that release routines
should be invoked upon it.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.fault_flag">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fault_flag</span></span></span><a class="headerlink" href="#c.fault_flag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fault flag definitions.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_WRITE</span></code></dt><dd><p>Fault was a write fault.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_MKWRITE</span></code></dt><dd><p>Fault was mkwrite of existing PTE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_ALLOW_RETRY</span></code></dt><dd><p>Allow to retry the fault if blocked.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_RETRY_NOWAIT</span></code></dt><dd><p>Don’t drop mmap_lock and wait when retrying.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_KILLABLE</span></code></dt><dd><p>The fault task is in SIGKILL killable region.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_TRIED</span></code></dt><dd><p>The fault has been tried once.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_USER</span></code></dt><dd><p>The fault originated in userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_REMOTE</span></code></dt><dd><p>The fault is not for current task/mm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_INSTRUCTION</span></code></dt><dd><p>The fault was during an instruction fetch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_INTERRUPTIBLE</span></code></dt><dd><p>The fault can be interrupted by non-fatal signals.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>About <strong>FAULT_FLAG_ALLOW_RETRY</strong> and <strong>FAULT_FLAG_TRIED</strong>: we can specify
whether we would allow page faults to retry by specifying these two
fault flags correctly.  Currently there can be three legal combinations:</p>
<ol class="loweralpha simple">
<li><dl class="simple">
<dt>ALLOW_RETRY and !TRIED:  this means the page fault allows retry, and</dt><dd><p>this is the first try</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ALLOW_RETRY and TRIED:   this means the page fault allows retry, and</dt><dd><p>we’ve already tried at least once</p>
</dd>
</dl>
</li>
<li><p>!ALLOW_RETRY and !TRIED: this means the page fault does not allow retry</p></li>
</ol>
<p>The unlisted combination (!ALLOW_RETRY &amp;&amp; TRIED) is illegal and should never
be used.  Note that page faults can be allowed to retry for multiple times,
in which case we’ll have an initial fault with flags (a) then later on
continuous faults with flags (b).  We should always try to detect pending
signals before a retry to make sure the continuous page faults can still be
interrupted if necessary.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.fault_flag_allow_retry_first">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fault_flag_allow_retry_first</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.fault_flag" title="fault_flag"><span class="n"><span class="pre">fault_flag</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fault_flag_allow_retry_first" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check ALLOW_RETRY the first time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fault_flag</span> <span class="pre">flags</span></code></dt><dd><p>Fault flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is mostly used for places where we want to try to avoid taking
the mmap_lock for too long a time when waiting for another condition
to change, in which case we can try to be polite to release the
mmap_lock in the first round to avoid potential starvation of other
processes that would also want the mmap_lock.</p>
<p><strong>Return</strong></p>
<p>true if the page fault allows retry and this is the first
attempt of the fault handling; false otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_order">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_order</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_order" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_order" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The allocation order of a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A folio is composed of 2^order pages.  See get_order() for the definition
of order.</p>
<p><strong>Return</strong></p>
<p>The order of the folio.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_get">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_get" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Increment the reference count on a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>May be called in any context, as long as you know that
you have a refcount on the folio.  If you do not already have one,
<a class="reference internal" href="#c.folio_try_get" title="folio_try_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_try_get()</span></code></a> may be the right interface for you to use.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_put" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Decrement the reference count on a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the folio’s reference count reaches zero, the memory will be
released back to the page allocator and may be used by another
allocation immediately.  Do not access the memory or the <a class="reference internal" href="#c.folio" title="folio"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span></code></a>
after calling <a class="reference internal" href="#c.folio_put" title="folio_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_put()</span></code></a> unless you can be sure that it wasn’t the
last reference.</p>
<p><strong>Context</strong></p>
<p>May be called in process or interrupt context, but not in NMI
context.  May be called while holding a spinlock.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_maybe_dma_pinned">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_maybe_dma_pinned</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_maybe_dma_pinned" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_maybe_dma_pinned" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report if a page is pinned for DMA.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks if a page has been pinned via a call to
a function in the pin_user_pages() family.</p>
<p>For non-huge pages, the return value is partially fuzzy: false is not fuzzy,
because it means “definitely not pinned for DMA”, but true means “probably
pinned for DMA, but possibly a false positive due to having at least
GUP_PIN_COUNTING_BIAS worth of normal page references”.</p>
<p>False positives are OK, because: a) it’s unlikely for a page to get that many
refcounts, and b) all the callers of this routine are expected to be able to
deal gracefully with a false positive.</p>
<p>For huge pages, the result will be exactly correct. That’s because we have
more tracking data available: the 3rd struct page in the compound page is
used to track the pincount (instead using of the GUP_PIN_COUNTING_BIAS
scheme).</p>
<p>For more information, please see <a class="reference internal" href="pin_user_pages.html"><span class="doc">pin_user_pages() and related calls</span></a>.</p>
<p><strong>Return</strong></p>
<p>True, if it is likely that the page has been “dma-pinned”.
False, if the page is definitely not dma-pinned.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_pfn">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_pfn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_pfn" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_pfn" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the Page Frame Number of a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A folio may contain multiple pages.  The pages have consecutive
Page Frame Numbers.</p>
<p><strong>Return</strong></p>
<p>The Page Frame Number of the first page in the folio.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_nr_pages">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_nr_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_nr_pages" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_nr_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of pages in the folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A positive power of two.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_next">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_next" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_next</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_next" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_next" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Move to the next physical folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio we’re currently operating on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you have physically contiguous memory which may span more than
one folio (eg a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_vec</span></code>), use this function to move from one
folio to the next.  Do not use it if the memory is only virtually
contiguous as the folios are almost certainly not adjacent to each
other.  This is the folio equivalent to writing <code class="docutils literal notranslate"><span class="pre">page++</span></code>.</p>
<p><strong>Context</strong></p>
<p>We assume that the folios are refcounted and/or locked at a
higher level and do not adjust the reference counts.</p>
<p><strong>Return</strong></p>
<p>The next <a class="reference internal" href="#c.folio" title="folio"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_shift">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_shift</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_shift" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_shift" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The size of the memory described by this folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A folio represents a number of bytes which is a power-of-two in size.
This function tells you which power-of-two the folio is.  See also
<a class="reference internal" href="#c.folio_size" title="folio_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_size()</span></code></a> and <a class="reference internal" href="#c.folio_order" title="folio_order"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_order()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>The caller should have a reference on the folio to prevent
it from being split.  It is not necessary for the folio to be locked.</p>
<p><strong>Return</strong></p>
<p>The base-2 logarithm of the size of this folio.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_size">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_size" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of bytes in a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>The caller should have a reference on the folio to prevent
it from being split.  It is not necessary for the folio to be locked.</p>
<p><strong>Return</strong></p>
<p>The number of bytes in this folio.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_vma_intersection">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_vma_intersection</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start_addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">end_addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_vma_intersection" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Look up the first VMA which intersects the interval</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>The process address space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start_addr</span></code></dt><dd><p>The inclusive start user address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_addr</span></code></dt><dd><p>The exclusive end user address.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The first VMA within the provided range, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.  Assumes
start_addr &lt; end_addr.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vma_lookup">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vma_lookup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vma_lookup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a VMA at a specific address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>The process address space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>The user address.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The vm_area_struct at the given address, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.vma_is_special_huge">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vma_is_special_huge</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vma_is_special_huge" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Are transhuge page-table entries considered special?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>Pointer to the struct vm_area_struct to consider</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Whether transhuge page-table entries are considered “special” following
the definition in vm_normal_page().</p>
<p><strong>Return</strong></p>
<p>true if transhuge page-table entries should be considered special,
false otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.seal_check_future_write">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">seal_check_future_write</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">seals</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.seal_check_future_write" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check for F_SEAL_FUTURE_WRITE flag and handle it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">seals</span></code></dt><dd><p>the seals to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>the vma to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether F_SEAL_FUTURE_WRITE is set; if so, do proper check/handling on
the vma flags.  Return 0 if check pass, or &lt;0 for errors.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_ref_count">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_ref_count</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_ref_count" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_ref_count" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The reference count on this folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The refcount is usually incremented by calls to <a class="reference internal" href="#c.folio_get" title="folio_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_get()</span></code></a> and
decremented by calls to <a class="reference internal" href="#c.folio_put" title="folio_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_put()</span></code></a>.  Some typical users of the
folio refcount:</p>
<ul class="simple">
<li><p>Each reference from a page table</p></li>
<li><p>The page cache</p></li>
<li><p>Filesystem private data</p></li>
<li><p>The LRU list</p></li>
<li><p>Pipes</p></li>
<li><p>Direct IO which references this page in the process address space</p></li>
</ul>
<p><strong>Return</strong></p>
<p>The number of references to this folio.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_try_get">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_try_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_try_get" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_try_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Attempt to increase the refcount on a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you do not already have a reference to a folio, you can attempt to
get one using this function.  It may fail if, for example, the folio
has been freed since you found a pointer to it, or it is frozen for
the purposes of splitting or migration.</p>
<p><strong>Return</strong></p>
<p>True if the reference count was successfully incremented.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_try_get_rcu">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_try_get_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_try_get_rcu" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_try_get_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Attempt to increase the refcount on a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a version of <a class="reference internal" href="#c.folio_try_get" title="folio_try_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_try_get()</span></code></a> optimised for non-SMP kernels.
If you are still holding the <a class="reference internal" href="kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> after looking up the
page and know that the page cannot have its refcount decreased to
zero in interrupt context, you can use this instead of <a class="reference internal" href="#c.folio_try_get" title="folio_try_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_try_get()</span></code></a>.</p>
<p>Example users include <a class="reference internal" href="#c.get_user_pages_fast" title="get_user_pages_fast"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_user_pages_fast()</span></code></a> (as pages are not unmapped
from interrupt context) and the page cache lookups (as pages are not
truncated from interrupt context).  We also know that pages are not
frozen in interrupt context for the purposes of splitting or migration.</p>
<p>You can also use this function if you’re holding a lock that prevents
pages being frozen &amp; removed; eg the i_pages lock for the page cache
or the mmap_sem or page table lock for page tables.  In this case,
it will always succeed, and you could have used a plain <a class="reference internal" href="#c.folio_get" title="folio_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_get()</span></code></a>,
but it’s sometimes more convenient to have a common function called
from both locked and RCU-protected contexts.</p>
<p><strong>Return</strong></p>
<p>True if the reference count was successfully incremented.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.is_highmem">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">is_highmem</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.is_highmem" title="zone"><span class="n"><span class="pre">zone</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zone</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.is_highmem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>helper function to quickly check if a struct zone is a highmem zone or not. This is an attempt to keep references to ZONE_{DMA/NORMAL/HIGHMEM/etc} in general code to a minimum.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zone</span> <span class="pre">*zone</span></code></dt><dd><p>pointer to struct zone variable</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 for a highmem zone, 0 otherwise</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_online_pgdat">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_online_pgdat</span></span></span><a class="headerlink" href="#c.for_each_online_pgdat" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_online_pgdat</span> <span class="pre">(pgdat)</span></code></p>
<blockquote>
<div><p>helper macro to iterate over all online nodes</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pgdat</span></code></dt><dd><p>pointer to a pg_data_t variable</p>
</dd>
</dl>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_zone">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_zone</span></span></span><a class="headerlink" href="#c.for_each_zone" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_zone</span> <span class="pre">(zone)</span></code></p>
<blockquote>
<div><p>helper macro to iterate over all memory zones</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">zone</span></code></dt><dd><p>pointer to struct zone variable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The user only needs to declare the zone variable, for_each_zone
fills it in.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.next_zones_zonelist">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">zoneref</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">next_zones_zonelist</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">zoneref</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">zone_type</span></span><span class="w"> </span><span class="n"><span class="pre">highest_zoneidx</span></span>, <span class="n"><span class="pre">nodemask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nodes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.next_zones_zonelist" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the next zone at or below highest_zoneidx within the allowed nodemask using a cursor within a zonelist as a starting point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zoneref</span> <span class="pre">*z</span></code></dt><dd><p>The cursor used as a starting point for the search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">zone_type</span> <span class="pre">highest_zoneidx</span></code></dt><dd><p>The zone index of the highest zone to return</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodemask_t</span> <span class="pre">*nodes</span></code></dt><dd><p>An optional nodemask to filter the zonelist with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the next zone at or below a given zone index that is
within the allowed nodemask using a cursor as the starting point for the
search. The zoneref returned is a cursor that represents the current zone
being examined. It should be advanced by one before calling
next_zones_zonelist again.</p>
<p><strong>Return</strong></p>
<p>the next zone at or below highest_zoneidx within the allowed
nodemask using a cursor within a zonelist as a starting point</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.first_zones_zonelist">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">zoneref</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">first_zones_zonelist</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.first_zones_zonelist" title="zonelist"><span class="n"><span class="pre">zonelist</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zonelist</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">zone_type</span></span><span class="w"> </span><span class="n"><span class="pre">highest_zoneidx</span></span>, <span class="n"><span class="pre">nodemask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nodes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.first_zones_zonelist" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the first zone at or below highest_zoneidx within the allowed nodemask in a zonelist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zonelist</span> <span class="pre">*zonelist</span></code></dt><dd><p>The zonelist to search for a suitable zone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">zone_type</span> <span class="pre">highest_zoneidx</span></code></dt><dd><p>The zone index of the highest zone to return</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodemask_t</span> <span class="pre">*nodes</span></code></dt><dd><p>An optional nodemask to filter the zonelist with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the first zone at or below a given zone index that is
within the allowed nodemask. The zoneref returned is a cursor that can be
used to iterate the zonelist with next_zones_zonelist by advancing it by
one before calling.</p>
<p>When no eligible zone is found, zoneref-&gt;zone is NULL (zoneref itself is
never NULL). This may happen either genuinely, or due to concurrent nodemask
update due to cpuset modification.</p>
<p><strong>Return</strong></p>
<p>Zoneref pointer for the first suitable zone found</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_zone_zonelist_nodemask">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_zone_zonelist_nodemask</span></span></span><a class="headerlink" href="#c.for_each_zone_zonelist_nodemask" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_zone_zonelist_nodemask</span> <span class="pre">(zone,</span> <span class="pre">z,</span> <span class="pre">zlist,</span> <span class="pre">highidx,</span> <span class="pre">nodemask)</span></code></p>
<blockquote>
<div><p>helper macro to iterate over valid zones in a zonelist at or below a given zone index and within a nodemask</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">zone</span></code></dt><dd><p>The current zone in the iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code></dt><dd><p>The current pointer within zonelist-&gt;_zonerefs being iterated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zlist</span></code></dt><dd><p>The zonelist being iterated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">highidx</span></code></dt><dd><p>The zone index of the highest zone to return</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodemask</span></code></dt><dd><p>Nodemask allowed by the allocator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator iterates though all zones at or below a given zone index and
within a given nodemask</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_zone_zonelist">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_zone_zonelist</span></span></span><a class="headerlink" href="#c.for_each_zone_zonelist" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_zone_zonelist</span> <span class="pre">(zone,</span> <span class="pre">z,</span> <span class="pre">zlist,</span> <span class="pre">highidx)</span></code></p>
<blockquote>
<div><p>helper macro to iterate over valid zones in a zonelist at or below a given zone index</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">zone</span></code></dt><dd><p>The current zone in the iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code></dt><dd><p>The current pointer within zonelist-&gt;zones being iterated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zlist</span></code></dt><dd><p>The zonelist being iterated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">highidx</span></code></dt><dd><p>The zone index of the highest zone to return</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator iterates though all zones at or below a given zone index.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.pfn_valid">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pfn_valid</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pfn_valid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if there is a valid memory map entry for a PFN</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>the page frame number to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if there is a valid memory map entry aka struct page for the <strong>pfn</strong>.
Note, that availability of the memory map entry does not imply that
there is actual usable memory at that <strong>pfn</strong>. The struct page may
represent a hole or an unusable page frame.</p>
<p><strong>Return</strong></p>
<p>1 for PFNs that have memory map entries and 0 otherwise</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mapping">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_mapping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mapping" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mapping" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the mapping where this folio is stored.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For folios which are in the page cache, return the mapping that this
page belongs to.  Folios in the swap cache return the swap mapping
this page is stored in (which is different from the mapping for the
swap file or swap device where the data is stored).</p>
<p>You can call this for folios which aren’t in the swap cache or page
cache and it will return NULL.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="genalloc.html" class="btn btn-neutral float-right" title="The genalloc/genpool subsystem" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="dma-isa-lpc.html" class="btn btn-neutral float-left" title="DMA with ISA and LPC devices" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>