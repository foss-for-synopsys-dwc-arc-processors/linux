

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Buffer Sharing and Synchronization &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Device links" href="device_link.html" />
    <link rel="prev" title="Bus-Independent Device Accesses" href="device-io.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.16.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Buffer Sharing and Synchronization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#shared-dma-buffers">Shared DMA Buffers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#userspace-interface-notes">Userspace Interface Notes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-operation-and-device-dma-access">Basic Operation and Device DMA Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-access-to-dma-buffer-objects">CPU Access to DMA Buffer Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-fence-poll-support">Implicit Fence Poll Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-buf-statistics">DMA-BUF statistics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-buffer-ioctls">DMA Buffer ioctls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-functions-and-structures-reference">Kernel Functions and Structures Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffer-mapping-helpers">Buffer Mapping Helpers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reservation-objects">Reservation Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dma-fences">DMA Fences</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dma-fence-cross-driver-contract">DMA Fence Cross-Driver Contract</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-fence-signalling-annotations">DMA Fence Signalling Annotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-fences-functions-reference">DMA Fences Functions Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-fence-array">DMA Fence Array</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-fence-chain">DMA Fence Chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-fence-uabi-sync-file">DMA Fence uABI/Sync File</a></li>
<li class="toctree-l4"><a class="reference internal" href="#indefinite-dma-fences">Indefinite DMA Fences</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recoverable-hardware-page-faults-implications">Recoverable Hardware Page Faults Implications</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="cxl/index.html">Compute Express Link</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Buffer Sharing and Synchronization</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/driver-api/dma-buf.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="buffer-sharing-and-synchronization">
<h1>Buffer Sharing and Synchronization<a class="headerlink" href="#buffer-sharing-and-synchronization" title="Permalink to this headline">¶</a></h1>
<p>The dma-buf subsystem provides the framework for sharing buffers for
hardware (DMA) access across multiple device drivers and subsystems, and
for synchronizing asynchronous hardware access.</p>
<p>This is used, for example, by drm “prime” multi-GPU support, but is of
course not limited to GPU use cases.</p>
<p>The three main components of this are: (1) dma-buf, representing a
sg_table and exposed to userspace as a file descriptor to allow passing
between devices, (2) fence, which provides a mechanism to signal when
one device has finished access, and (3) reservation, which manages the
shared or exclusive fence(s) associated with the buffer.</p>
<div class="section" id="shared-dma-buffers">
<h2>Shared DMA Buffers<a class="headerlink" href="#shared-dma-buffers" title="Permalink to this headline">¶</a></h2>
<p>This document serves as a guide to device-driver writers on what is the dma-buf
buffer sharing API, how to use it for exporting and using shared buffers.</p>
<p>Any device driver which wishes to be a part of DMA buffer sharing, can do so as
either the ‘exporter’ of buffers, or the ‘user’ or ‘importer’ of buffers.</p>
<p>Say a driver A wants to use buffers created by driver B, then we call B as the
exporter, and A as buffer-user/importer.</p>
<p>The exporter</p>
<blockquote>
<div><ul class="simple">
<li><p>implements and manages operations in <a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_ops</span></code></a> for the buffer,</p></li>
<li><p>allows other users to share the buffer by using dma_buf sharing APIs,</p></li>
<li><p>manages the details of buffer allocation, wrapped in a <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">dma_buf</span></code></a>,</p></li>
<li><p>decides about the actual backing storage where this allocation happens,</p></li>
<li><p>and takes care of any migration of scatterlist - for all (shared) users of
this buffer.</p></li>
</ul>
</div></blockquote>
<p>The buffer-user</p>
<blockquote>
<div><ul class="simple">
<li><p>is one of (many) sharing users of the buffer.</p></li>
<li><p>doesn’t need to worry about how the buffer is allocated, or where.</p></li>
<li><p>and needs a mechanism to get access to the scatterlist that makes up this
buffer in memory, mapped into its own address space, so it can access the
same area of memory. This interface is provided by <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">dma_buf_attachment</span></code></a>.</p></li>
</ul>
</div></blockquote>
<p>Any exporters or users of the dma-buf buffer sharing framework must have a
‘select DMA_SHARED_BUFFER’ in their respective Kconfigs.</p>
<div class="section" id="userspace-interface-notes">
<h3>Userspace Interface Notes<a class="headerlink" href="#userspace-interface-notes" title="Permalink to this headline">¶</a></h3>
<p>Mostly a DMA buffer file descriptor is simply an opaque object for userspace,
and hence the generic interface exposed is very minimal. There’s a few things to
consider though:</p>
<ul>
<li><p>Since kernel 3.12 the dma-buf FD supports the llseek system call, but only
with offset=0 and whence=SEEK_END|SEEK_SET. SEEK_SET is supported to allow
the usual size discover pattern size = SEEK_END(0); SEEK_SET(0). Every other
llseek operation will report -EINVAL.</p>
<p>If llseek on dma-buf FDs isn’t support the kernel will report -ESPIPE for all
cases. Userspace can use this to detect support for discovering the dma-buf
size using llseek.</p>
</li>
<li><p>In order to avoid fd leaks on exec, the FD_CLOEXEC flag must be set
on the file descriptor.  This is not just a resource leak, but a
potential security hole.  It could give the newly exec’d application
access to buffers, via the leaked fd, to which it should otherwise
not be permitted access.</p>
<p>The problem with doing this via a separate fcntl() call, versus doing it
atomically when the fd is created, is that this is inherently racy in a
multi-threaded app[3].  The issue is made worse when it is library code
opening/creating the file descriptor, as the application may not even be
aware of the fd’s.</p>
<p>To avoid this problem, userspace must have a way to request O_CLOEXEC
flag be set when the dma-buf fd is created.  So any API provided by
the exporting driver to create a dmabuf fd must provide a way to let
userspace control setting of O_CLOEXEC flag passed in to dma_buf_fd().</p>
</li>
<li><p>Memory mapping the contents of the DMA buffer is also supported. See the
discussion below on <a class="reference internal" href="#cpu-access-to-dma-buffer-objects">CPU Access to DMA Buffer Objects</a> for the full details.</p></li>
<li><p>The DMA buffer FD is also pollable, see <a class="reference internal" href="#implicit-fence-poll-support">Implicit Fence Poll Support</a> below for
details.</p></li>
<li><p>The DMA buffer FD also supports a few dma-buf-specific ioctls, see
<a class="reference internal" href="#dma-buffer-ioctls">DMA Buffer ioctls</a> below for details.</p></li>
</ul>
</div>
<div class="section" id="basic-operation-and-device-dma-access">
<h3>Basic Operation and Device DMA Access<a class="headerlink" href="#basic-operation-and-device-dma-access" title="Permalink to this headline">¶</a></h3>
<p>For device DMA access to a shared DMA buffer the usual sequence of operations
is fairly simple:</p>
<ol class="arabic">
<li><p>The exporter defines his exporter instance using
<a class="reference internal" href="#c.DEFINE_DMA_BUF_EXPORT_INFO" title="DEFINE_DMA_BUF_EXPORT_INFO"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEFINE_DMA_BUF_EXPORT_INFO()</span></code></a> and calls dma_buf_export() to wrap a private
buffer object into a <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>. It then exports that <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> to userspace
as a file descriptor by calling dma_buf_fd().</p></li>
<li><p>Userspace passes this file-descriptors to all drivers it wants this buffer
to share with: First the filedescriptor is converted to a <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> using
dma_buf_get(). Then the buffer is attached to the device using
dma_buf_attach().</p>
<p>Up to this stage the exporter is still free to migrate or reallocate the
backing storage.</p>
</li>
<li><p>Once the buffer is attached to all devices userspace can initiate DMA
access to the shared buffer. In the kernel this is done by calling
dma_buf_map_attachment() and dma_buf_unmap_attachment().</p></li>
<li><p>Once a driver is done with a shared buffer it needs to call
dma_buf_detach() (after cleaning up any mappings) and then release the
reference acquired with dma_buf_get() by calling dma_buf_put().</p></li>
</ol>
<p>For the detailed semantics exporters are expected to implement see
<a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops</span></code></a>.</p>
</div>
<div class="section" id="cpu-access-to-dma-buffer-objects">
<h3>CPU Access to DMA Buffer Objects<a class="headerlink" href="#cpu-access-to-dma-buffer-objects" title="Permalink to this headline">¶</a></h3>
<p>There are mutliple reasons for supporting CPU access to a dma buffer object:</p>
<ul>
<li><p>Fallback operations in the kernel, for example when a device is connected
over USB and the kernel needs to shuffle the data around first before
sending it away. Cache coherency is handled by braketing any transactions
with calls to dma_buf_begin_cpu_access() and dma_buf_end_cpu_access()
access.</p>
<p>Since for most kernel internal dma-buf accesses need the entire buffer, a
vmap interface is introduced. Note that on very old 32-bit architectures
vmalloc space might be limited and result in vmap calls failing.</p>
<p>Interfaces:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void \*dma_buf_vmap(struct dma_buf \*dmabuf)
void dma_buf_vunmap(struct dma_buf \*dmabuf, void \*vaddr)
</pre></div>
</div>
<p>The vmap call can fail if there is no vmap support in the exporter, or if
it runs out of vmalloc space. Note that the dma-buf layer keeps a reference
count for all vmap access and calls down into the exporter’s vmap function
only when no vmapping exists, and only unmaps it once. Protection against
concurrent vmap/vunmap calls is provided by taking the <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.lock</span></code></a> mutex.</p>
</li>
<li><p>For full compatibility on the importer side with existing userspace
interfaces, which might already support mmap’ing buffers. This is needed in
many processing pipelines (e.g. feeding a software rendered image into a
hardware pipeline, thumbnail creation, snapshots, …). Also, Android’s ION
framework already supported this and for DMA buffer file descriptors to
replace ION buffers mmap support was needed.</p>
<p>There is no special interfaces, userspace simply calls mmap on the dma-buf
fd. But like for CPU access there’s a need to braket the actual access,
which is handled by the ioctl (DMA_BUF_IOCTL_SYNC). Note that
DMA_BUF_IOCTL_SYNC can fail with -EAGAIN or -EINTR, in which case it must
be restarted.</p>
<p>Some systems might need some sort of cache coherency management e.g. when
CPU and GPU domains are being accessed through dma-buf at the same time.
To circumvent this problem there are begin/end coherency markers, that
forward directly to existing dma-buf device drivers vfunc hooks. Userspace
can make use of those markers through the DMA_BUF_IOCTL_SYNC ioctl. The
sequence would be used like following:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>mmap dma-buf fd</p></li>
<li><p>for each drawing/upload cycle in CPU 1. SYNC_START ioctl, 2. read/write
to mmap area 3. SYNC_END ioctl. This can be repeated as often as you
want (with the new data being consumed by say the GPU or the scanout
device)</p></li>
<li><p>munmap once you don’t need the buffer any more</p></li>
</ul>
</div></blockquote>
<p>For correctness and optimal performance, it is always required to use
SYNC_START and SYNC_END before and after, respectively, when accessing the
mapped address. Userspace cannot rely on coherent access, even when there
are systems where it just works without calling these ioctls.</p>
</div></blockquote>
</li>
<li><p>And as a CPU fallback in userspace processing pipelines.</p>
<p>Similar to the motivation for kernel cpu access it is again important that
the userspace code of a given importing subsystem can use the same
interfaces with a imported dma-buf buffer object as with a native buffer
object. This is especially important for drm where the userspace part of
contemporary OpenGL, X, and other drivers is huge, and reworking them to
use a different way to mmap a buffer rather invasive.</p>
<p>The assumption in the current dma-buf interfaces is that redirecting the
initial mmap is all that’s needed. A survey of some of the existing
subsystems shows that no driver seems to do any nefarious thing like
syncing up with outstanding asynchronous processing on the device or
allocating special resources at fault time. So hopefully this is good
enough, since adding interfaces to intercept pagefaults and allow pte
shootdowns would increase the complexity quite a bit.</p>
<p>Interface:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int dma_buf_mmap(struct dma_buf \*, struct vm_area_struct \*,
               unsigned long);
</pre></div>
</div>
<p>If the importing subsystem simply provides a special-purpose mmap call to
set up a mapping in userspace, calling do_mmap with <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.file</span></code></a> will
equally achieve that for a dma-buf object.</p>
</li>
</ul>
</div>
<div class="section" id="implicit-fence-poll-support">
<h3>Implicit Fence Poll Support<a class="headerlink" href="#implicit-fence-poll-support" title="Permalink to this headline">¶</a></h3>
<p>To support cross-device and cross-driver synchronization of buffer access
implicit fences (represented internally in the kernel with <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span></code></a>)
can be attached to a <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>. The glue for that and a few related things are
provided in the <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> structure.</p>
<p>Userspace can query the state of these implicitly tracked fences using poll()
and related system calls:</p>
<ul class="simple">
<li><p>Checking for EPOLLIN, i.e. read access, can be use to query the state of the
most recent write or exclusive fence.</p></li>
<li><p>Checking for EPOLLOUT, i.e. write access, can be used to query the state of
all attached fences, shared and exclusive ones.</p></li>
</ul>
<p>Note that this only signals the completion of the respective fences, i.e. the
DMA transfers are complete. Cache flushing and any other necessary
preparations before CPU access can begin still need to happen.</p>
</div>
<div class="section" id="dma-buf-statistics">
<h3>DMA-BUF statistics<a class="headerlink" href="#dma-buf-statistics" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/dma_buf/bufinfo</span></code> provides an overview of every DMA-BUF
in the system. However, since debugfs is not safe to be mounted in
production, procfs and sysfs can be used to gather DMA-BUF statistics on
production systems.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">/proc/&lt;pid&gt;/fdinfo/&lt;fd&gt;</span></code> files in procfs can be used to gather
information about DMA-BUF fds. Detailed documentation about the interface
is present in <a class="reference internal" href="../filesystems/proc.html"><span class="doc">The /proc Filesystem</span></a>.</p>
<p>Unfortunately, the existing procfs interfaces can only provide information
about the DMA-BUFs for which processes hold fds or have the buffers mmapped
into their address space. This necessitated the creation of the DMA-BUF sysfs
statistics interface to provide per-buffer information on production systems.</p>
<p>The interface at <code class="docutils literal notranslate"><span class="pre">/sys/kernel/dma-buf/buffers</span></code> exposes information about
every DMA-BUF when <code class="docutils literal notranslate"><span class="pre">CONFIG_DMABUF_SYSFS_STATS</span></code> is enabled.</p>
<p>The following stats are exposed by the interface:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/kernel/dmabuf/buffers/&lt;inode_number&gt;/exporter_name</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/kernel/dmabuf/buffers/&lt;inode_number&gt;/size</span></code></p></li>
</ul>
<p>The information in the interface can also be used to derive per-exporter
statistics. The data from the interface can be gathered on error conditions
or other important events to provide a snapshot of DMA-BUF usage.
It can also be collected periodically by telemetry to monitor various metrics.</p>
<p>Detailed documentation about the interface is present in
Documentation/ABI/testing/sysfs-kernel-dmabuf-buffers.</p>
</div>
<div class="section" id="dma-buffer-ioctls">
<h3>DMA Buffer ioctls<a class="headerlink" href="#dma-buffer-ioctls" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_buf_sync">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_sync</span></span></span><a class="headerlink" href="#c.dma_buf_sync" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Synchronize with CPU access.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_sync {
  __u64 flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Set of access flags</p>
<dl class="simple">
<dt>DMA_BUF_SYNC_START:</dt><dd><p>Indicates the start of a map access session.</p>
</dd>
<dt>DMA_BUF_SYNC_END:</dt><dd><p>Indicates the end of a map access session.</p>
</dd>
<dt>DMA_BUF_SYNC_READ:</dt><dd><p>Indicates that the mapped DMA buffer will be read by the
client via the CPU map.</p>
</dd>
<dt>DMA_BUF_SYNC_WRITE:</dt><dd><p>Indicates that the mapped DMA buffer will be written by the
client via the CPU map.</p>
</dd>
<dt>DMA_BUF_SYNC_RW:</dt><dd><p>An alias for DMA_BUF_SYNC_READ | DMA_BUF_SYNC_WRITE.</p>
</dd>
</dl>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a DMA buffer is accessed from the CPU via mmap, it is not always
possible to guarantee coherency between the CPU-visible map and underlying
memory.  To manage coherency, DMA_BUF_IOCTL_SYNC must be used to bracket
any CPU access to give the kernel the chance to shuffle memory around if
needed.</p>
<p>Prior to accessing the map, the client must call DMA_BUF_IOCTL_SYNC
with DMA_BUF_SYNC_START and the appropriate read/write flags.  Once the
access is complete, the client should call DMA_BUF_IOCTL_SYNC with
DMA_BUF_SYNC_END and the same read/write flags.</p>
<p>The synchronization provided via DMA_BUF_IOCTL_SYNC only provides cache
coherency.  It does not prevent other processes or devices from
accessing the memory at the same time.  If synchronization with a GPU or
other device driver is required, it is the client’s responsibility to
wait for buffer to be ready for reading or writing before calling this
ioctl with DMA_BUF_SYNC_START.  Likewise, the client must ensure that
follow-up work is not submitted to GPU or other device driver until
after this ioctl has been called with DMA_BUF_SYNC_END?</p>
<p>If the driver or API with which the client is interacting uses implicit
synchronization, waiting for prior work to complete can be done via
poll() on the DMA buffer file descriptor.  If the driver or API requires
explicit synchronization, the client may have to wait on a sync_file or
other synchronization primitive outside the scope of the DMA buffer API.</p>
</div>
<div class="section" id="kernel-functions-and-structures-reference">
<h3>Kernel Functions and Structures Reference<a class="headerlink" href="#kernel-functions-and-structures-reference" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_buf_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_ops</span></span></span><a class="headerlink" href="#c.dma_buf_ops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>operations possible on <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a></p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_ops {
  bool cache_sgt_mapping;
  int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
  void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
  int (*pin)(struct dma_buf_attachment *attach);
  void (*unpin)(struct dma_buf_attachment *attach);
  struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
  void (*unmap_dma_buf)(struct dma_buf_attachment *,struct sg_table *, enum dma_data_direction);
  void (*release)(struct dma_buf *);
  int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
  int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
  int (*mmap)(struct dma_buf *, struct vm_area_struct *vma);
  int (*vmap)(struct dma_buf *dmabuf, struct dma_buf_map *map);
  void (*vunmap)(struct dma_buf *dmabuf, struct dma_buf_map *map);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">cache_sgt_mapping</span></code></dt><dd><p>If true the framework will cache the first mapping made for each
attachment. This avoids creating mappings for attachments multiple
times.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">attach</span></code></dt><dd><p>This is called from dma_buf_attach() to make sure that a given
<a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment.dev</span></code></a> can access the provided <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>. Exporters
which support buffer objects in special locations like VRAM or
device-specific carveout areas should check whether the buffer could
be move to system memory (or directly accessed by the provided
device), and otherwise need to fail the attach operation.</p>
<p>The exporter should also in general check whether the current
allocation fulfills the DMA constraints of the new device. If this
is not the case, and the allocation cannot be moved, it should also
fail the attach operation.</p>
<p>Any exporter-private housekeeping data can be stored in the
<a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment.priv</span></code></a> pointer.</p>
<p>This callback is optional.</p>
<p>Returns:</p>
<p>0 on success, negative error code on failure. It might return -EBUSY
to signal that backing storage is already allocated and incompatible
with the requirements of requesting device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach</span></code></dt><dd><p>This is called by dma_buf_detach() to release a <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment</span></code></a>.
Provided so that exporters can clean up any housekeeping for an
<a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment</span></code></a>.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pin</span></code></dt><dd><p>This is called by dma_buf_pin() and lets the exporter know that the
DMA-buf can’t be moved any more. Ideally, the exporter should
pin the buffer so that it is generally accessible by all
devices.</p>
<p>This is called with the <code class="xref c c-type docutils literal notranslate"><span class="pre">dmabuf.resv</span></code> object locked and is mutual
exclusive with <strong>cache_sgt_mapping</strong>.</p>
<p>This is called automatically for non-dynamic importers from
dma_buf_attach().</p>
<p>Note that similar to non-dynamic exporters in their <strong>map_dma_buf</strong>
callback the driver must guarantee that the memory is available for
use and cleared of any old data by the time this function returns.
Drivers which pipeline their buffer moves internally must wait for
all moves and clears to complete.</p>
<p>Returns:</p>
<p>0 on success, negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unpin</span></code></dt><dd><p>This is called by dma_buf_unpin() and lets the exporter know that the
DMA-buf can be moved again.</p>
<p>This is called with the dmabuf-&gt;resv object locked and is mutual
exclusive with <strong>cache_sgt_mapping</strong>.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map_dma_buf</span></code></dt><dd><p>This is called by dma_buf_map_attachment() and is used to map a
shared <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> into device address space, and it is mandatory. It
can only be called if <strong>attach</strong> has been called successfully.</p>
<p>This call may sleep, e.g. when the backing storage first needs to be
allocated, or moved to a location suitable for all currently attached
devices.</p>
<p>Note that any specific buffer attributes required for this function
should get added to device_dma_parameters accessible via
<a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device.dma_params</span></code></a> from the <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment</span></code></a>. The <strong>attach</strong> callback
should also check these constraints.</p>
<p>If this is being called for the first time, the exporter can now
choose to scan through the list of attachments for this buffer,
collate the requirements of the attached devices, and choose an
appropriate backing storage for the buffer.</p>
<p>Based on enum dma_data_direction, it might be possible to have
multiple users accessing at the same time (for reading, maybe), or
any other kind of sharing that the exporter might wish to make
available to buffer-users.</p>
<p>This is always called with the dmabuf-&gt;resv object locked when
the dynamic_mapping flag is true.</p>
<p>Note that for non-dynamic exporters the driver must guarantee that
that the memory is available for use and cleared of any old data by
the time this function returns.  Drivers which pipeline their buffer
moves internally must wait for all moves and clears to complete.
Dynamic exporters do not need to follow this rule: For non-dynamic
importers the buffer is already pinned through <strong>pin</strong>, which has the
same requirements. Dynamic importers otoh are required to obey the
dma_resv fences.</p>
<p>Returns:</p>
<p>A <code class="xref c c-type docutils literal notranslate"><span class="pre">sg_table</span></code> scatter list of the backing storage of the DMA buffer,
already mapped into the device address space of the <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a> attached
with the provided <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment</span></code></a>. The addresses and lengths in
the scatter list are PAGE_SIZE aligned.</p>
<p>On failure, returns a negative error value wrapped into a pointer.
May also return -EINTR when a signal was received while being
blocked.</p>
<p>Note that exporters should not try to cache the scatter list, or
return the same one for multiple calls. Caching is done either by the
DMA-BUF code (for non-dynamic importers) or the importer. Ownership
of the scatter list is transferred to the caller, and returned by
<strong>unmap_dma_buf</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unmap_dma_buf</span></code></dt><dd><p>This is called by dma_buf_unmap_attachment() and should unmap and
release the <code class="xref c c-type docutils literal notranslate"><span class="pre">sg_table</span></code> allocated in <strong>map_dma_buf</strong>, and it is mandatory.
For static dma_buf handling this might also unpin the backing
storage if this is the last mapping of the DMA buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>Called after the last dma_buf_put to release the <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>, and
mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">begin_cpu_access</span></code></dt><dd><p>This is called from dma_buf_begin_cpu_access() and allows the
exporter to ensure that the memory is actually coherent for cpu
access. The exporter also needs to ensure that cpu access is coherent
for the access direction. The direction can be used by the exporter
to optimize the cache flushing, i.e. access with a different
direction (read instead of write) might return stale or even bogus
data (e.g. when the exporter needs to copy the data to temporary
storage).</p>
<p>Note that this is both called through the DMA_BUF_IOCTL_SYNC IOCTL
command for userspace mappings established through <strong>mmap</strong>, and also
for kernel mappings established with <strong>vmap</strong>.</p>
<p>This callback is optional.</p>
<p>Returns:</p>
<p>0 on success or a negative error code on failure. This can for
example fail when the backing storage can’t be allocated. Can also
return -ERESTARTSYS or -EINTR when the call has been interrupted and
needs to be restarted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end_cpu_access</span></code></dt><dd><p>This is called from dma_buf_end_cpu_access() when the importer is
done accessing the CPU. The exporter can use this to flush caches and
undo anything else done in <strong>begin_cpu_access</strong>.</p>
<p>This callback is optional.</p>
<p>Returns:</p>
<p>0 on success or a negative error code on failure. Can return
-ERESTARTSYS or -EINTR when the call has been interrupted and needs
to be restarted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap</span></code></dt><dd><p>This callback is used by the dma_buf_mmap() function</p>
<p>Note that the mapping needs to be incoherent, userspace is expected
to bracket CPU access using the DMA_BUF_IOCTL_SYNC interface.</p>
<p>Because dma-buf buffers have invariant size over their lifetime, the
dma-buf core checks whether a vma is too large and rejects such
mappings. The exporter hence does not need to duplicate this check.
Drivers do not need to check this themselves.</p>
<p>If an exporter needs to manually flush caches and hence needs to fake
coherency for mmap support, it needs to be able to zap all the ptes
pointing at the backing storage. Now linux mm needs a <a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">address_space</span></code></a> associated with the struct file stored in vma-&gt;vm_file
to do that with the function unmap_mapping_range. But the dma_buf
framework only backs every dma_buf fd with the anon_file struct file,
i.e. all dma_bufs share the same file.</p>
<p>Hence exporters need to setup their own file (and address_space)
association by setting vma-&gt;vm_file and adjusting vma-&gt;vm_pgoff in
the dma_buf mmap callback. In the specific case of a gem driver the
exporter could use the shmem file already provided by gem (and set
vm_pgoff = 0). Exporters can then zap ptes by unmapping the
corresponding range of the <a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span></code></a> associated with their
own file.</p>
<p>This callback is optional.</p>
<p>Returns:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vmap</span></code></dt><dd><p>[optional] creates a virtual mapping for the buffer into kernel
address space. Same restrictions as for vmap and friends apply.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vunmap</span></code></dt><dd><p>[optional] unmaps a vmap from the buffer</p>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_buf">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf</span></span></span><a class="headerlink" href="#c.dma_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>shared buffer object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf {
  size_t size;
  struct file *file;
  struct list_head attachments;
  const struct dma_buf_ops *ops;
  struct mutex lock;
  unsigned vmapping_counter;
  struct dma_buf_map vmap_ptr;
  const char *exp_name;
  const char *name;
  spinlock_t name_lock;
  struct module *owner;
  struct list_head list_node;
  void *priv;
  struct dma_resv *resv;
  wait_queue_head_t poll;
  struct dma_buf_poll_cb_t {
    struct dma_fence_cb cb;
    wait_queue_head_t *poll;
    __poll_t active;
  } cb_in, cb_out;
#ifdef CONFIG_DMABUF_SYSFS_STATS;
  struct dma_buf_sysfs_entry {
    struct kobject kobj;
    struct dma_buf *dmabuf;
  } *sysfs_entry;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the buffer; invariant over the lifetime of the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>File pointer used for sharing buffers across, and for refcounting.
See dma_buf_get() and dma_buf_put().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">attachments</span></code></dt><dd><p>List of dma_buf_attachment that denotes all devices attached,
protected by <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> lock <strong>resv</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>dma_buf_ops associated with this buffer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Used internally to serialize list manipulation, attach/detach and
vmap/unmap. Note that in many cases this is superseeded by
<a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> on <strong>resv</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vmapping_counter</span></code></dt><dd><p>Used internally to refcnt the vmaps returned by dma_buf_vmap().
Protected by <strong>lock</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vmap_ptr</span></code></dt><dd><p>The current vmap ptr if <strong>vmapping_counter</strong> &gt; 0. Protected by <strong>lock</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exp_name</span></code></dt><dd><p>Name of the exporter; useful for debugging. See the
DMA_BUF_SET_NAME IOCTL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Userspace-provided name; useful for accounting and debugging,
protected by <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> on <strong>resv</strong> and <strong>name_lock</strong> for read access.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name_lock</span></code></dt><dd><p>Spinlock to protect name acces for read access.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>Pointer to exporter module; used for refcounting when exporter is a
kernel module.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list_node</span></code></dt><dd><p>node for dma_buf accounting and debugging.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>exporter specific private data for this buffer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resv</span></code></dt><dd><p>Reservation object linked to this dma-buf.</p>
<p>IMPLICIT SYNCHRONIZATION RULES:</p>
<p>Drivers which support implicit synchronization of buffer access as
e.g. exposed in <a class="reference internal" href="#implicit-fence-poll-support">Implicit Fence Poll Support</a> must follow the
below rules.</p>
<ul class="simple">
<li><p>Drivers must add a shared fence through <a class="reference internal" href="#c.dma_resv_add_shared_fence" title="dma_resv_add_shared_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_add_shared_fence()</span></code></a>
for anything the userspace API considers a read access. This highly
depends upon the API and window system.</p></li>
<li><p>Similarly drivers must set the exclusive fence through
<a class="reference internal" href="#c.dma_resv_add_excl_fence" title="dma_resv_add_excl_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_add_excl_fence()</span></code></a> for anything the userspace API considers
write access.</p></li>
<li><p>Drivers may just always set the exclusive fence, since that only
causes unecessarily synchronization, but no correctness issues.</p></li>
<li><p>Some drivers only expose a synchronous userspace API with no
pipelining across drivers. These do not set any fences for their
access. An example here is v4l.</p></li>
</ul>
<p>DYNAMIC IMPORTER RULES:</p>
<p>Dynamic importers, see <a class="reference internal" href="#c.dma_buf_attachment_is_dynamic" title="dma_buf_attachment_is_dynamic"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_attachment_is_dynamic()</span></code></a>, have
additional constraints on how they set up fences:</p>
<ul class="simple">
<li><p>Dynamic importers must obey the exclusive fence and wait for it to
signal before allowing access to the buffer’s underlying storage
through the device.</p></li>
<li><p>Dynamic importers should set fences for any access that they can’t
disable immediately from their <a class="reference internal" href="#c.dma_buf_attach_ops" title="dma_buf_attach_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attach_ops.move_notify</span></code></a>
callback.</p></li>
</ul>
<p>IMPORTANT:</p>
<p>All drivers must obey the <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> rules, specifically the
rules for updating fences, see <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.fence_excl</span></code></a> and
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.fence</span></code></a>. If these dependency rules are broken access tracking
can be lost resulting in use after free issues.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll</span></code></dt><dd><p>for userspace poll support</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs_entry</span></code></dt><dd><p>For exposing information about this buffer in sysfs. See also
<a class="reference internal" href="#dma-buf-statistics">DMA-BUF statistics</a> for the uapi this enables.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This represents a shared buffer, created by calling dma_buf_export(). The
userspace representation is a normal file descriptor, which can be created by
calling dma_buf_fd().</p>
<p>Shared dma buffers are reference counted using dma_buf_put() and
<a class="reference internal" href="#c.get_dma_buf" title="get_dma_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_dma_buf()</span></code></a>.</p>
<p>Device DMA access is handled by the separate <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span></code></a>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_buf_attach_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_attach_ops</span></span></span><a class="headerlink" href="#c.dma_buf_attach_ops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>importer operations for an attachment</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_attach_ops {
  bool allow_peer2peer;
  void (*move_notify)(struct dma_buf_attachment *attach);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">allow_peer2peer</span></code></dt><dd><p>If this is set to true the importer must be able to handle peer
resources without struct pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">move_notify</span></code></dt><dd><p>[optional] notification that the DMA-buf is moving</p>
<p>If this callback is provided the framework can avoid pinning the
backing store while mappings exists.</p>
<p>This callback is called with the lock of the reservation object
associated with the dma_buf held and the mapping function must be
called with this lock held as well. This makes sure that no mapping
is created concurrently with an ongoing move operation.</p>
<p>Mappings stay valid and are not directly affected by this callback.
But the DMA-buf can now be in a different physical location, so all
mappings should be destroyed and re-created as soon as possible.</p>
<p>New mappings can be created after this callback returns, and will
point to the new location of the DMA-buf.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attachment operations implemented by the importer.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_buf_attachment">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_attachment</span></span></span><a class="headerlink" href="#c.dma_buf_attachment" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>holds device-buffer attachment data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_attachment {
  struct dma_buf *dmabuf;
  struct device *dev;
  struct list_head node;
  struct sg_table *sgt;
  enum dma_data_direction dir;
  bool peer2peer;
  const struct dma_buf_attach_ops *importer_ops;
  void *importer_priv;
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dmabuf</span></code></dt><dd><p>buffer for this attachment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device attached to the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>list of dma_buf_attachment, protected by dma_resv lock of the dmabuf.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sgt</span></code></dt><dd><p>cached mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dir</span></code></dt><dd><p>direction of cached mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer2peer</span></code></dt><dd><p>true if the importer can handle peer resources without pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">importer_ops</span></code></dt><dd><p>importer operations for this attachment, if provided
dma_buf_map/unmap_attachment() must be called with the dma_resv lock held.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">importer_priv</span></code></dt><dd><p>importer specific attachment data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>exporter specific attachment data.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure holds the attachment information between the dma_buf buffer
and its user device(s). The list contains one attachment struct per device
attached to the buffer.</p>
<p>An attachment is created by calling dma_buf_attach(), and released again by
calling dma_buf_detach(). The DMA mapping itself needed to initiate a
transfer is created by dma_buf_map_attachment() and freed again by calling
dma_buf_unmap_attachment().</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_buf_export_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_export_info</span></span></span><a class="headerlink" href="#c.dma_buf_export_info" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>holds information needed to export a dma_buf</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_export_info {
  const char *exp_name;
  struct module *owner;
  const struct dma_buf_ops *ops;
  size_t size;
  int flags;
  struct dma_resv *resv;
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">exp_name</span></code></dt><dd><p>name of the exporter - useful for debugging.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>pointer to exporter module - used for refcounting kernel module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Attach allocator-defined dma buf ops to the new buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the buffer - invariant over the lifetime of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>mode flags for the file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resv</span></code></dt><dd><p>reservation-object, NULL to allocate default one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>Attach private data of allocator to this buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure holds the information required to export the buffer. Used
with dma_buf_export() only.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEFINE_DMA_BUF_EXPORT_INFO">
<span class="sig-name descname"><span class="n"><span class="pre">DEFINE_DMA_BUF_EXPORT_INFO</span></span></span><a class="headerlink" href="#c.DEFINE_DMA_BUF_EXPORT_INFO" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEFINE_DMA_BUF_EXPORT_INFO</span> <span class="pre">(name)</span></code></p>
<blockquote>
<div><p>helper macro for exporters</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>export-info name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>DEFINE_DMA_BUF_EXPORT_INFO macro defines the <a class="reference internal" href="#c.dma_buf_export_info" title="dma_buf_export_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_export_info</span></code></a>,
zeroes it out and pre-populates exp_name in it.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_dma_buf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_dma_buf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dmabuf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_dma_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convenience wrapper for get_file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    pointer to dma_buf</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments the reference count on the dma-buf, needed in case of drivers
that either need to create additional references to the dmabuf on the
kernel side.  For example, an exporter that needs to keep a dmabuf ptr
so that subsequent exports don’t create a new dmabuf.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_buf_is_dynamic">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_is_dynamic</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dmabuf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_is_dynamic" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if a DMA-buf uses dynamic mappings.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>the DMA-buf to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if a DMA-buf exporter wants to be called with the dma_resv
locked for the map/unmap callbacks, false if it doesn’t wants to be called
with the lock held.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_buf_attachment_is_dynamic">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_attachment_is_dynamic</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><span class="n"><span class="pre">dma_buf_attachment</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attach</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_attachment_is_dynamic" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if a DMA-buf attachment uses dynamic mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>the DMA-buf attachment to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if a DMA-buf importer wants to call the map/unmap functions with
the dma_resv lock held.</p>
</div>
<div class="section" id="buffer-mapping-helpers">
<h3>Buffer Mapping Helpers<a class="headerlink" href="#buffer-mapping-helpers" title="Permalink to this headline">¶</a></h3>
<p>Calling dma-buf’s vmap operation returns a pointer to the buffer’s memory.
Depending on the location of the buffer, users may have to access it with
I/O operations or memory load/store operations. For example, copying to
system memory could be done with <a class="reference internal" href="../core-api/kernel-api.html#c.memcpy" title="memcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">memcpy()</span></code></a>, copying to I/O memory would be
done with memcpy_toio().</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// pointer to system memory</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr_iomem</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// pointer to I/O memory</span>
<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">_iomem</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>When using dma-buf’s vmap operation, the returned pointer is encoded as
<a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a>.
<a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a> stores the buffer’s address in
system or I/O memory and a flag that signals the required method of
accessing the buffer. Use the returned instance and the helper functions
to access the buffer’s memory in the correct way.</p>
<p>The type <a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a> and its helpers are
actually independent from the dma-buf infrastructure. When sharing buffers
among devices, drivers have to know the location of the memory to access
the buffers in a safe way. <a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a>
solves this problem for dma-buf and its users. If other drivers or
sub-systems require similar functionality, the type could be generalized
and moved to a more prominent header file.</p>
<p>Open-coding access to <a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a> is
considered bad style. Rather then accessing its fields directly, use one
of the provided helper functions, or implement your own. For example,
instances of <a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a> can be initialized
statically with <a class="reference internal" href="#c.DMA_BUF_MAP_INIT_VADDR" title="DMA_BUF_MAP_INIT_VADDR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DMA_BUF_MAP_INIT_VADDR()</span></code></a>, or at runtime with
<a class="reference internal" href="#c.dma_buf_map_set_vaddr" title="dma_buf_map_set_vaddr"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_set_vaddr()</span></code></a>. These helpers will set an address in system memory.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">dma_buf_map</span> <span class="n">map</span> <span class="o">=</span> <span class="n">DMA_BUF_MAP_INIT_VADDR</span><span class="p">(</span><span class="mh">0xdeadbeaf</span><span class="p">);</span>

<span class="n">dma_buf_map_set_vaddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">.</span> <span class="mh">0xdeadbeaf</span><span class="p">);</span>
</pre></div>
</div>
<p>To set an address in I/O memory, use <a class="reference internal" href="#c.dma_buf_map_set_vaddr_iomem" title="dma_buf_map_set_vaddr_iomem"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_set_vaddr_iomem()</span></code></a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dma_buf_map_set_vaddr_iomem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">.</span> <span class="mh">0xdeadbeaf</span><span class="p">);</span>
</pre></div>
</div>
<p>Instances of <a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a> do not have to be cleaned up, but
can be cleared to NULL with <a class="reference internal" href="#c.dma_buf_map_clear" title="dma_buf_map_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_clear()</span></code></a>. Cleared mappings
always refer to system memory.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dma_buf_map_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">);</span>
</pre></div>
</div>
<p>Test if a mapping is valid with either <a class="reference internal" href="#c.dma_buf_map_is_set" title="dma_buf_map_is_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_is_set()</span></code></a> or
<a class="reference internal" href="#c.dma_buf_map_is_null" title="dma_buf_map_is_null"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_is_null()</span></code></a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">dma_buf_map_is_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dma_buf_map_is_null</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">))</span>
        <span class="c1">// always true</span>
</pre></div>
</div>
<p>Instances of <a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a> can be compared
for equality with <a class="reference internal" href="#c.dma_buf_map_is_equal" title="dma_buf_map_is_equal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_is_equal()</span></code></a>. Mappings the point to different
memory spaces, system or I/O, are never equal. That’s even true if both
spaces are located in the same address space, both mappings contain the
same address value, or both mappings refer to NULL.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">dma_buf_map</span> <span class="n">sys_map</span><span class="p">;</span> <span class="c1">// refers to system memory</span>
<span class="k">struct</span> <span class="nc">dma_buf_map</span> <span class="n">io_map</span><span class="p">;</span> <span class="c1">// refers to I/O memory</span>

<span class="k">if</span> <span class="p">(</span><span class="n">dma_buf_map_is_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sys_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_map</span><span class="p">))</span>
        <span class="c1">// always false</span>
</pre></div>
</div>
<p>A set up instance of <a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a> can be used to access or manipulate
the buffer memory. Depending on the location of the memory, the provided
helpers will pick the correct operations. Data can be copied into the memory
with <a class="reference internal" href="#c.dma_buf_map_memcpy_to" title="dma_buf_map_memcpy_to"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_memcpy_to()</span></code></a>. The address can be manipulated with
<a class="reference internal" href="#c.dma_buf_map_incr" title="dma_buf_map_incr"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_incr()</span></code></a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// source buffer</span>
<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// length of src</span>

<span class="n">dma_buf_map_memcpy_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="n">dma_buf_map_incr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span> <span class="c1">// go to first byte after the memcpy</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_buf_map">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_map</span></span></span><a class="headerlink" href="#c.dma_buf_map" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pointer to vmap’ed dma-buf memory.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_map {
  union {
    void __iomem *vaddr_iomem;
    void *vaddr;
  };
  bool is_iomem;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vaddr_iomem</span></code></dt><dd><p>The buffer’s address if in I/O memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vaddr</span></code></dt><dd><p>The buffer’s address if in system memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_iomem</span></code></dt><dd><p>True if the dma-buf memory is located in I/O
memory, or false otherwise.</p>
</dd>
</dl>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DMA_BUF_MAP_INIT_VADDR">
<span class="sig-name descname"><span class="n"><span class="pre">DMA_BUF_MAP_INIT_VADDR</span></span></span><a class="headerlink" href="#c.DMA_BUF_MAP_INIT_VADDR" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DMA_BUF_MAP_INIT_VADDR</span> <span class="pre">(vaddr_)</span></code></p>
<blockquote>
<div><p>Initializes <a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a> to an address in system memory</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vaddr_</span></code></dt><dd><p>A system-memory address</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_buf_map_set_vaddr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_map_set_vaddr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><span class="n"><span class="pre">dma_buf_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vaddr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_map_set_vaddr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets a dma-buf mapping structure to an address in system memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span> <span class="pre">*map</span></code></dt><dd><p>The dma-buf mapping structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*vaddr</span></code></dt><dd><p>A system-memory address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the address and clears the I/O-memory flag.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_buf_map_set_vaddr_iomem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_map_set_vaddr_iomem</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><span class="n"><span class="pre">dma_buf_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__iomem</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vaddr_iomem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_map_set_vaddr_iomem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets a dma-buf mapping structure to an address in I/O memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span> <span class="pre">*map</span></code></dt><dd><p>The dma-buf mapping structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*vaddr_iomem</span></code></dt><dd><p>An I/O-memory address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the address and the I/O-memory flag.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_buf_map_is_equal">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_map_is_equal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><span class="n"><span class="pre">dma_buf_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lhs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><span class="n"><span class="pre">dma_buf_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rhs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_map_is_equal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compares two dma-buf mapping structures for equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_buf_map</span> <span class="pre">*lhs</span></code></dt><dd><p>The dma-buf mapping structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_buf_map</span> <span class="pre">*rhs</span></code></dt><dd><p>A dma-buf mapping structure to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Two dma-buf mapping structures are equal if they both refer to the same type of memory
and to the same address within that memory.</p>
<p><strong>Return</strong></p>
<p>True is both structures are equal, or false otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_buf_map_is_null">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_map_is_null</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><span class="n"><span class="pre">dma_buf_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_map_is_null" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tests for a dma-buf mapping to be NULL</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_buf_map</span> <span class="pre">*map</span></code></dt><dd><p>The dma-buf mapping structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Depending on the state of <a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a>.is_iomem, tests if the
mapping is NULL.</p>
<p><strong>Return</strong></p>
<p>True if the mapping is NULL, or false otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_buf_map_is_set">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_map_is_set</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><span class="n"><span class="pre">dma_buf_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_map_is_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tests is the dma-buf mapping has been set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_buf_map</span> <span class="pre">*map</span></code></dt><dd><p>The dma-buf mapping structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Depending on the state of <a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a>.is_iomem, tests if the
mapping has been set.</p>
<p><strong>Return</strong></p>
<p>True if the mapping is been set, or false otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_buf_map_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_map_clear</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><span class="n"><span class="pre">dma_buf_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_map_clear" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clears a dma-buf mapping structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span> <span class="pre">*map</span></code></dt><dd><p>The dma-buf mapping structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clears all fields to zero; including <a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span></code></a>.is_iomem. So
mapping structures that were set to point to I/O memory are reset for
system memory. Pointers are cleared to NULL. This is the default.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_buf_map_memcpy_to">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_map_memcpy_to</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><span class="n"><span class="pre">dma_buf_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_map_memcpy_to" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Memcpy into dma-buf mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span> <span class="pre">*dst</span></code></dt><dd><p>The dma-buf mapping structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*src</span></code></dt><dd><p>The source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>The number of byte in src</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data into a dma-buf mapping. The source buffer is in system
memory. Depending on the buffer’s location, the helper picks the correct
method of accessing the memory.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_buf_map_incr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_buf_map_incr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_buf_map" title="dma_buf_map"><span class="n"><span class="pre">dma_buf_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">incr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_map_incr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Increments the address stored in a dma-buf mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_map</span> <span class="pre">*map</span></code></dt><dd><p>The dma-buf mapping structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">incr</span></code></dt><dd><p>The number of bytes to increment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments the address stored in a dma-buf mapping. Depending on the
buffer’s location, the correct value will be updated.</p>
</div>
</div>
<div class="section" id="reservation-objects">
<h2>Reservation Objects<a class="headerlink" href="#reservation-objects" title="Permalink to this headline">¶</a></h2>
<p>The reservation object provides a mechanism to manage shared and
exclusive fences associated with a buffer.  A reservation object
can have attached one exclusive fence (normally associated with
write operations) or N shared fences (read operations).  The RCU
mechanism is used to protect read access to fences from locked
write-side updates.</p>
<p>See <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> for more details.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize a reservation object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_fini" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>destroys a reservation object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_reserve_shared">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_reserve_shared</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_fences</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_reserve_shared" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reserve space to add shared fences to a dma_resv.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_fences</span></code></dt><dd><p>number of fences we want to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called before <a class="reference internal" href="#c.dma_resv_add_shared_fence" title="dma_resv_add_shared_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_add_shared_fence()</span></code></a>.  Must
be called with <strong>obj</strong> locked through <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a>.</p>
<p>Note that the preallocated slots need to be re-reserved if <strong>obj</strong> is unlocked
at any time before calling <a class="reference internal" href="#c.dma_resv_add_shared_fence" title="dma_resv_add_shared_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_add_shared_fence()</span></code></a>. This is validated
when CONFIG_DEBUG_MUTEXES is enabled.</p>
<p>RETURNS
Zero for success, or -errno</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_reset_shared_max">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_reset_shared_max</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_reset_shared_max" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reset shared fences for debugging</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the dma_resv object to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset the number of pre-reserved shared slots to test that drivers do
correct slot allocation using <a class="reference internal" href="#c.dma_resv_reserve_shared" title="dma_resv_reserve_shared"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_reserve_shared()</span></code></a>. See also
<a class="reference internal" href="#c.dma_resv_list" title="dma_resv_list"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv_list.shared_max</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_add_shared_fence">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_add_shared_fence</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_add_shared_fence" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a fence to a shared slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the shared fence to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a fence to a shared slot, <strong>obj</strong> must be locked with <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a>, and
<a class="reference internal" href="#c.dma_resv_reserve_shared" title="dma_resv_reserve_shared"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_reserve_shared()</span></code></a> has been called.</p>
<p>See also <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.fence</span></code></a> for a discussion of the semantics.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_add_excl_fence">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_add_excl_fence</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_add_excl_fence" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add an exclusive fence.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the exclusive fence to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a fence to the exclusive slot. <strong>obj</strong> must be locked with <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a>.
Note that this function replaces all fences attached to <strong>obj</strong>, see also
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.fence_excl</span></code></a> for a discussion of the semantics.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_iter_first_unlocked">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_iter_first_unlocked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><span class="n"><span class="pre">dma_resv_iter</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cursor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_first_unlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>first fence in an unlocked dma_resv obj.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>the cursor with the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the first fence from an unlocked dma_resv obj.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_iter_next_unlocked">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_iter_next_unlocked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><span class="n"><span class="pre">dma_resv_iter</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cursor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_next_unlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>next fence in an unlocked dma_resv obj.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>the cursor with the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the next fence from an unlocked dma_resv obj.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_iter_first">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_iter_first</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><span class="n"><span class="pre">dma_resv_iter</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cursor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_first" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>first fence from a locked dma_resv object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>cursor to record the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the first fence in the dma_resv object while holding the
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.lock</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_iter_next">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_iter_next</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><span class="n"><span class="pre">dma_resv_iter</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cursor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_next" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>next fence from a locked dma_resv object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>cursor to record the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the next fences from the dma_resv object while holding the
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.lock</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_copy_fences">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_copy_fences</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_copy_fences" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy all fences from src to dst.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*dst</span></code></dt><dd><p>the destination reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*src</span></code></dt><dd><p>the source reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy all fences from src to dst. dst-lock must be held.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_get_fences">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_get_fences</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence_excl</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shared_count</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shared</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_get_fences" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get an object’s shared and exclusive fences without update side lock held</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**fence_excl</span></code></dt><dd><p>the returned exclusive fence (or NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*shared_count</span></code></dt><dd><p>the number of shared fences returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">***shared</span></code></dt><dd><p>the array of shared fence ptrs returned (array is krealloc’d to
the required size, and must be freed by caller)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve all fences from the reservation object. If the pointer for the
exclusive fence is not specified the fence is put into the array of the
shared fences as well. Returns either zero or -ENOMEM.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_wait_timeout">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_wait_timeout</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">wait_all</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">intr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_wait_timeout" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait on reservation’s objects shared and/or exclusive fences.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">wait_all</span></code></dt><dd><p>if true, wait on all fences, else wait on just exclusive fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt><dd><p>if true, do interruptible wait</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies or zero to return immediately</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callers are not required to hold specific locks, but maybe hold
<a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> already
RETURNS
Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or
greater than zer on success.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_test_signaled">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_test_signaled</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">test_all</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_test_signaled" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if a reservation object’s fences have been signaled.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">test_all</span></code></dt><dd><p>if true, test all fences, otherwise only test the exclusive
fence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callers are not required to hold specific locks, but maybe hold
<a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> already.</p>
<p>RETURNS</p>
<p>True if all fences signaled, else false.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_resv_list">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_list</span></span></span><a class="headerlink" href="#c.dma_resv_list" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>a list of shared fences</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_resv_list {
  struct rcu_head rcu;
  u32 shared_count, shared_max;
  struct dma_fence __rcu *shared[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt><dd><p>for internal use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shared_count</span></code></dt><dd><p>table of shared fences</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shared_max</span></code></dt><dd><p>for growing shared fence table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shared</span></code></dt><dd><p>shared fence table</p>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_resv">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv</span></span></span><a class="headerlink" href="#c.dma_resv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>a reservation object manages fences for a buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_resv {
  struct ww_mutex lock;
  seqcount_ww_mutex_t seq;
  struct dma_fence __rcu *fence_excl;
  struct dma_resv_list __rcu *fence;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Update side lock. Don’t use directly, instead use the wrapper
functions like <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> and <a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a>.</p>
<p>Drivers which use the reservation object to manage memory dynamically
also use this lock to protect buffer object state like placement,
allocation policies or throughout command submission.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seq</span></code></dt><dd><p>Sequence count for managing RCU read-side synchronization, allows
read-only access to <strong>fence_excl</strong> and <strong>fence</strong> while ensuring we take a
consistent snapshot.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_excl</span></code></dt><dd><p>The exclusive fence, if there is one currently.</p>
<p>There are two ways to update this fence:</p>
<ul class="simple">
<li><p>First by calling <a class="reference internal" href="#c.dma_resv_add_excl_fence" title="dma_resv_add_excl_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_add_excl_fence()</span></code></a>, which replaces all
fences attached to the reservation object. To guarantee that no
fences are lost, this new fence must signal only after all previous
fences, both shared and exclusive, have signalled. In some cases it
is convenient to achieve that by attaching a <a class="reference internal" href="#c.dma_fence_array" title="dma_fence_array"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_array</span></code></a>
with all the new and old fences.</p></li>
<li><p>Alternatively the fence can be set directly, which leaves the
shared fences unchanged. To guarantee that no fences are lost, this
new fence must signal only after the previous exclusive fence has
signalled. Since the shared fences are staying intact, it is not
necessary to maintain any ordering against those. If semantically
only a new access is added without actually treating the previous
one as a dependency the exclusive fences can be strung together
using <a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_chain</span></code></a>.</p></li>
</ul>
<p>Note that actual semantics of what an exclusive or shared fence mean
is defined by the user, for reservation objects shared across drivers
see <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.resv</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>List of current shared fences.</p>
<p>There are no ordering constraints of shared fences against the
exclusive fence slot. If a waiter needs to wait for all access, it
has to wait for both sets of fences to signal.</p>
<p>A new fence is added by calling <a class="reference internal" href="#c.dma_resv_add_shared_fence" title="dma_resv_add_shared_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_add_shared_fence()</span></code></a>. Since
this often needs to be done past the point of no return in command
submission it cannot fail, and therefore sufficient slots need to be
reserved by calling <a class="reference internal" href="#c.dma_resv_reserve_shared" title="dma_resv_reserve_shared"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_reserve_shared()</span></code></a>.</p>
<p>Note that actual semantics of what an exclusive or shared fence mean
is defined by the user, for reservation objects shared across drivers
see <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.resv</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>There are multiple uses for this, with sometimes slightly different rules in
how the fence slots are used.</p>
<p>One use is to synchronize cross-driver access to a <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a>, either for
dynamic buffer management or just to handle implicit synchronization between
different users of the buffer in userspace. See <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.resv</span></code></a> for a more
in-depth discussion.</p>
<p>The other major use is to manage access and locking within a driver in a
buffer based memory manager. struct ttm_buffer_object is the canonical
example here, since this is where reservation objects originated from. But
use in drivers is spreading and some drivers also manage <a class="reference internal" href="../gpu/drm-mm.html#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_gem_object</span></code></a> with the same scheme.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_resv_iter">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_iter</span></span></span><a class="headerlink" href="#c.dma_resv_iter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>current position into the dma_resv fences</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_resv_iter {
  struct dma_resv *obj;
  bool all_fences;
  struct dma_fence *fence;
  unsigned int seq;
  unsigned int index;
  struct dma_resv_list *fences;
  unsigned int shared_count;
  bool is_restarted;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>The dma_resv object we iterate over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">all_fences</span></code></dt><dd><p>If all fences should be returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>the currently handled fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seq</span></code></dt><dd><p>sequence number to check for modifications</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>index into the shared fences</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fences</span></code></dt><dd><p>the shared fences; private, <em>MUST</em> not dereference</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shared_count</span></code></dt><dd><p>number of shared fences</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_restarted</span></code></dt><dd><p>true if this is the first returned fence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Don’t touch this directly in the driver, use the accessor function instead.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_iter_begin">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_iter_begin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><span class="n"><span class="pre">dma_resv_iter</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cursor</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">all_fences</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_begin" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize a dma_resv_iter object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>The dma_resv_iter object to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>The dma_resv object which we want to iterate over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">all_fences</span></code></dt><dd><p>If all fences should be returned or just the exclusive one</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_iter_end">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_iter_end</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><span class="n"><span class="pre">dma_resv_iter</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cursor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_end" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cleanup a dma_resv_iter object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>the dma_resv_iter object which should be cleaned up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure that the reference to the fence in the cursor is properly
dropped.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_iter_is_exclusive">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_iter_is_exclusive</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><span class="n"><span class="pre">dma_resv_iter</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cursor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_is_exclusive" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>test if the current fence is the exclusive one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>the cursor of the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the currently returned fence is the exclusive one.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_iter_is_restarted">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_iter_is_restarted</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><span class="n"><span class="pre">dma_resv_iter</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cursor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_is_restarted" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>test if this is the first fence after a restart</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>the cursor with the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if this is the first fence in an iteration after a restart.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.dma_resv_for_each_fence_unlocked">
<span class="sig-name descname"><span class="n"><span class="pre">dma_resv_for_each_fence_unlocked</span></span></span><a class="headerlink" href="#c.dma_resv_for_each_fence_unlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">dma_resv_for_each_fence_unlocked</span> <span class="pre">(cursor,</span> <span class="pre">fence)</span></code></p>
<blockquote>
<div><p>unlocked fence iterator</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cursor</span></code></dt><dd><p>a <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>the current fence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the fences in a <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> object without holding the
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.lock</span></code></a> and using RCU instead. The cursor needs to be initialized
with <a class="reference internal" href="#c.dma_resv_iter_begin" title="dma_resv_iter_begin"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_begin()</span></code></a> and cleaned up with <a class="reference internal" href="#c.dma_resv_iter_end" title="dma_resv_iter_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_end()</span></code></a>. Inside
the iterator a reference to the dma_fence is held and the RCU lock dropped.
When the dma_resv is modified the iteration starts over again.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.dma_resv_for_each_fence">
<span class="sig-name descname"><span class="n"><span class="pre">dma_resv_for_each_fence</span></span></span><a class="headerlink" href="#c.dma_resv_for_each_fence" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">dma_resv_for_each_fence</span> <span class="pre">(cursor,</span> <span class="pre">obj,</span> <span class="pre">all_fences,</span> <span class="pre">fence)</span></code></p>
<blockquote>
<div><p>fence iterator</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cursor</span></code></dt><dd><p>a <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>a dma_resv object pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">all_fences</span></code></dt><dd><p>true if all fences should be returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>the current fence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the fences in a <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> object while holding the
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.lock</span></code></a>. <strong>all_fences</strong> controls if the shared fences are returned as
well. The cursor initialisation is part of the iterator and the fence stays
valid as long as the lock is held and so no extra reference to the fence is
taken.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_lock">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_lock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ww_acquire_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lock the reservation object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the locking context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Locks the reservation object for exclusive access and modification. Note,
that the lock is only against other writers, readers will run concurrently
with a writer under RCU. The seqlock is used to notify readers if they
overlap with a writer.</p>
<p>As the reservation object may be locked by multiple parties in an
undefined order, a #ww_acquire_ctx is passed to unwind if a cycle
is detected. See ww_mutex_lock() and ww_acquire_init(). A reservation
object may be locked by itself by passing NULL as <strong>ctx</strong>.</p>
<p>When a die situation is indicated by returning -EDEADLK all locks held by
<strong>ctx</strong> must be unlocked and then <a class="reference internal" href="#c.dma_resv_lock_slow" title="dma_resv_lock_slow"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock_slow()</span></code></a> called on <strong>obj</strong>.</p>
<p>Unlocked by calling <a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a>.</p>
<p>See also <a class="reference internal" href="#c.dma_resv_lock_interruptible" title="dma_resv_lock_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock_interruptible()</span></code></a> for the interruptible variant.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_lock_interruptible">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_lock_interruptible</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ww_acquire_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_lock_interruptible" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lock the reservation object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the locking context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Locks the reservation object interruptible for exclusive access and
modification. Note, that the lock is only against other writers, readers
will run concurrently with a writer under RCU. The seqlock is used to
notify readers if they overlap with a writer.</p>
<p>As the reservation object may be locked by multiple parties in an
undefined order, a #ww_acquire_ctx is passed to unwind if a cycle
is detected. See ww_mutex_lock() and ww_acquire_init(). A reservation
object may be locked by itself by passing NULL as <strong>ctx</strong>.</p>
<p>When a die situation is indicated by returning -EDEADLK all locks held by
<strong>ctx</strong> must be unlocked and then <a class="reference internal" href="#c.dma_resv_lock_slow_interruptible" title="dma_resv_lock_slow_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock_slow_interruptible()</span></code></a> called on
<strong>obj</strong>.</p>
<p>Unlocked by calling <a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_lock_slow">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_lock_slow</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ww_acquire_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_lock_slow" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>slowpath lock the reservation object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the locking context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires the reservation object after a die case. This function
will sleep until the lock becomes available. See <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> as
well.</p>
<p>See also <a class="reference internal" href="#c.dma_resv_lock_slow_interruptible" title="dma_resv_lock_slow_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock_slow_interruptible()</span></code></a> for the interruptible variant.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_lock_slow_interruptible">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_lock_slow_interruptible</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ww_acquire_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_lock_slow_interruptible" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>slowpath lock the reservation object, interruptible</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the locking context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires the reservation object interruptible after a die case. This function
will sleep until the lock becomes available. See
<a class="reference internal" href="#c.dma_resv_lock_interruptible" title="dma_resv_lock_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock_interruptible()</span></code></a> as well.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_trylock">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_trylock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_trylock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>trylock the reservation object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tries to lock the reservation object for exclusive access and modification.
Note, that the lock is only against other writers, readers will run
concurrently with a writer under RCU. The seqlock is used to notify readers
if they overlap with a writer.</p>
<p>Also note that since no context is provided, no deadlock protection is
possible, which is also not needed for a trylock.</p>
<p>Returns true if the lock was acquired, false otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_is_locked">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_is_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_is_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is the reservation object locked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the mutex is locked, false if unlocked.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_locking_ctx">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ww_acquire_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_locking_ctx</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_locking_ctx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns the context used to lock the object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the context used to lock a reservation object or NULL if no context
was used or the object is not locked at all.</p>
<p>WARNING: This interface is pretty horrible, but TTM needs it because it
doesn’t pass the struct ww_acquire_ctx around in some very long callchains.
Everyone else just uses it to check whether they’re holding a reservation or
not.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_unlock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unlock the reservation object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the reservation object following exclusive access.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_excl_fence">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_excl_fence</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_excl_fence" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the object’s exclusive fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the exclusive fence (if any). Caller must either hold the objects
through <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> or the RCU read side lock through <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>,
or one of the variants of each</p>
<p>RETURNS
The exclusive fence or NULL</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_get_excl_unlocked">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_get_excl_unlocked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_get_excl_unlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the reservation object’s exclusive fence, without lock held.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If there is an exclusive fence, this atomically increments it’s
reference count and returns it.</p>
<p>RETURNS
The exclusive fence or NULL if none</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_resv_shared_list">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv_list" title="dma_resv_list"><span class="n"><span class="pre">dma_resv_list</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_resv_shared_list</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_shared_list" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the reservation object’s shared fence list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the shared fence list. Caller must either hold the objects
through <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> or the RCU read side lock through <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>,
or one of the variants of each</p>
</div>
<div class="section" id="dma-fences">
<h2>DMA Fences<a class="headerlink" href="#dma-fences" title="Permalink to this headline">¶</a></h2>
<p>DMA fences, represented by <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span></code></a>, are the kernel internal
synchronization primitive for DMA operations like GPU rendering, video
encoding/decoding, or displaying buffers on a screen.</p>
<p>A fence is initialized using <a class="reference internal" href="#c.dma_fence_init" title="dma_fence_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_init()</span></code></a> and completed using
<a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>. Fences are associated with a context, allocated through
<a class="reference internal" href="#c.dma_fence_context_alloc" title="dma_fence_context_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_context_alloc()</span></code></a>, and all fences on the same context are
fully ordered.</p>
<p>Since the purposes of fences is to facilitate cross-device and
cross-application synchronization, there’s multiple ways to use one:</p>
<ul class="simple">
<li><p>Individual fences can be exposed as a <a class="reference internal" href="#c.sync_file" title="sync_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">sync_file</span></code></a>, accessed as a file
descriptor from userspace, created by calling <a class="reference internal" href="#c.sync_file_create" title="sync_file_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">sync_file_create()</span></code></a>. This is
called explicit fencing, since userspace passes around explicit
synchronization points.</p></li>
<li><p>Some subsystems also have their own explicit fencing primitives, like
<a class="reference internal" href="../gpu/drm-mm.html#c.drm_syncobj" title="drm_syncobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_syncobj</span></code></a>. Compared to <a class="reference internal" href="#c.sync_file" title="sync_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">sync_file</span></code></a>, a <a class="reference internal" href="../gpu/drm-mm.html#c.drm_syncobj" title="drm_syncobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_syncobj</span></code></a> allows the underlying
fence to be updated.</p></li>
<li><p>Then there’s also implicit fencing, where the synchronization points are
implicitly passed around as part of shared <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> instances. Such
implicit fences are stored in <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> through the
<a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.resv</span></code></a> pointer.</p></li>
</ul>
<div class="section" id="dma-fence-cross-driver-contract">
<h3>DMA Fence Cross-Driver Contract<a class="headerlink" href="#dma-fence-cross-driver-contract" title="Permalink to this headline">¶</a></h3>
<p>Since <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> provide a cross driver contract, all drivers must follow the
same rules:</p>
<ul class="simple">
<li><p>Fences must complete in a reasonable time. Fences which represent kernels
and shaders submitted by userspace, which could run forever, must be backed
up by timeout and gpu hang recovery code. Minimally that code must prevent
further command submission and force complete all in-flight fences, e.g.
when the driver or hardware do not support gpu reset, or if the gpu reset
failed for some reason. Ideally the driver supports gpu recovery which only
affects the offending userspace context, and no other userspace
submissions.</p></li>
<li><p>Drivers may have different ideas of what completion within a reasonable
time means. Some hang recovery code uses a fixed timeout, others a mix
between observing forward progress and increasingly strict timeouts.
Drivers should not try to second guess timeout handling of fences from
other drivers.</p></li>
<li><p>To ensure there’s no deadlocks of <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> against other locks
drivers should annotate all code required to reach <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>,
which completes the fences, with <a class="reference internal" href="#c.dma_fence_begin_signalling" title="dma_fence_begin_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_begin_signalling()</span></code></a> and
<a class="reference internal" href="#c.dma_fence_end_signalling" title="dma_fence_end_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_end_signalling()</span></code></a>.</p></li>
<li><p>Drivers are allowed to call <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> while holding <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a>.
This means any code required for fence completion cannot acquire a
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> lock. Note that this also pulls in the entire established
locking hierarchy around <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> and <a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a>.</p></li>
<li><p>Drivers are allowed to call <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> from their <code class="xref c c-type docutils literal notranslate"><span class="pre">shrinker</span></code>
callbacks. This means any code required for fence completion cannot
allocate memory with GFP_KERNEL.</p></li>
<li><p>Drivers are allowed to call <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> from their <code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_notifier</span></code>
respectively <code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_interval_notifier</span></code> callbacks. This means any code required
for fence completeion cannot allocate memory with GFP_NOFS or GFP_NOIO.
Only GFP_ATOMIC is permissible, which might fail.</p></li>
</ul>
<p>Note that only GPU drivers have a reasonable excuse for both requiring
<code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_interval_notifier</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">shrinker</span></code> callbacks at the same time as having to
track asynchronous compute work using <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a>. No driver outside of
drivers/gpu should ever call <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> in such contexts.</p>
</div>
<div class="section" id="dma-fence-signalling-annotations">
<h3>DMA Fence Signalling Annotations<a class="headerlink" href="#dma-fence-signalling-annotations" title="Permalink to this headline">¶</a></h3>
<p>Proving correctness of all the kernel code around <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> through code
review and testing is tricky for a few reasons:</p>
<ul class="simple">
<li><p>It is a cross-driver contract, and therefore all drivers must follow the
same rules for lock nesting order, calling contexts for various functions
and anything else significant for in-kernel interfaces. But it is also
impossible to test all drivers in a single machine, hence brute-force N vs.
N testing of all combinations is impossible. Even just limiting to the
possible combinations is infeasible.</p></li>
<li><p>There is an enormous amount of driver code involved. For render drivers
there’s the tail of command submission, after fences are published,
scheduler code, interrupt and workers to process job completion,
and timeout, gpu reset and gpu hang recovery code. Plus for integration
with core mm with have <code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_notifier</span></code>, respectively <code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_interval_notifier</span></code>,
and <code class="xref c c-type docutils literal notranslate"><span class="pre">shrinker</span></code>. For modesetting drivers there’s the commit tail functions
between when fences for an atomic modeset are published, and when the
corresponding vblank completes, including any interrupt processing and
related workers. Auditing all that code, across all drivers, is not
feasible.</p></li>
<li><p>Due to how many other subsystems are involved and the locking hierarchies
this pulls in there is extremely thin wiggle-room for driver-specific
differences. <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> interacts with almost all of the core memory
handling through page fault handlers via <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a>, <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> and
<a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a>. On the other side it also interacts through all
allocation sites through <code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_notifier</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">shrinker</span></code>.</p></li>
</ul>
<p>Furthermore lockdep does not handle cross-release dependencies, which means
any deadlocks between <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> and <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> can’t be caught
at runtime with some quick testing. The simplest example is one thread
waiting on a <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> while holding a lock:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lock(A);
dma_fence_wait(B);
unlock(A);
</pre></div>
</div>
<p>while the other thread is stuck trying to acquire the same lock, which
prevents it from signalling the fence the previous thread is stuck waiting
on:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lock(A);
unlock(A);
dma_fence_signal(B);
</pre></div>
</div>
<p>By manually annotating all code relevant to signalling a <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> we can
teach lockdep about these dependencies, which also helps with the validation
headache since now lockdep can check all the rules for us:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cookie = dma_fence_begin_signalling();
lock(A);
unlock(A);
dma_fence_signal(B);
dma_fence_end_signalling(cookie);
</pre></div>
</div>
<p>For using <a class="reference internal" href="#c.dma_fence_begin_signalling" title="dma_fence_begin_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_begin_signalling()</span></code></a> and <a class="reference internal" href="#c.dma_fence_end_signalling" title="dma_fence_end_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_end_signalling()</span></code></a> to
annotate critical sections the following rules need to be observed:</p>
<ul class="simple">
<li><p>All code necessary to complete a <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> must be annotated, from the
point where a fence is accessible to other threads, to the point where
<a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> is called. Un-annotated code can contain deadlock issues,
and due to the very strict rules and many corner cases it is infeasible to
catch these just with review or normal stress testing.</p></li>
<li><p><a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> deserves a special note, since the readers are only
protected by rcu. This means the signalling critical section starts as soon
as the new fences are installed, even before <a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a> is called.</p></li>
<li><p>The only exception are fast paths and opportunistic signalling code, which
calls <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> purely as an optimization, but is not required to
guarantee completion of a <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a>. The usual example is a wait IOCTL
which calls <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>, while the mandatory completion path goes
through a hardware interrupt and possible job completion worker.</p></li>
<li><p>To aid composability of code, the annotations can be freely nested, as long
as the overall locking hierarchy is consistent. The annotations also work
both in interrupt and process context. Due to implementation details this
requires that callers pass an opaque cookie from
<a class="reference internal" href="#c.dma_fence_begin_signalling" title="dma_fence_begin_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_begin_signalling()</span></code></a> to <a class="reference internal" href="#c.dma_fence_end_signalling" title="dma_fence_end_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_end_signalling()</span></code></a>.</p></li>
<li><p>Validation against the cross driver contract is implemented by priming
lockdep with the relevant hierarchy at boot-up. This means even just
testing with a single device is enough to validate a driver, at least as
far as deadlocks with <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> against <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> are
concerned.</p></li>
</ul>
</div>
<div class="section" id="dma-fences-functions-reference">
<h3>DMA Fences Functions Reference<a class="headerlink" href="#dma-fences-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_get_stub">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_get_stub</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_stub" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return a signaled fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return a stub fence which is already signaled. The fence’s
timestamp corresponds to the first time after boot this
function is called.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_allocate_private_stub">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_allocate_private_stub</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_allocate_private_stub" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return a private, signaled fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return a newly allocated and signaled stub fence.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_context_alloc">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_context_alloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_context_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate an array of fence contexts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">num</span></code></dt><dd><p>amount of contexts to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will return the first index of the number of fence contexts
allocated.  The fence context is used for setting <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.context</span></code></a> to a
unique number by passing the context to <a class="reference internal" href="#c.dma_fence_init" title="dma_fence_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_init()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_begin_signalling">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_begin_signalling</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_begin_signalling" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>begin a critical DMA fence signalling section</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should use this to annotate the beginning of any code section
required to eventually complete <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> by calling <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>.</p>
<p>The end of these critical sections are annotated with
<a class="reference internal" href="#c.dma_fence_end_signalling" title="dma_fence_end_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_end_signalling()</span></code></a>.</p>
<p>Opaque cookie needed by the implementation, which needs to be passed to
<a class="reference internal" href="#c.dma_fence_end_signalling" title="dma_fence_end_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_end_signalling()</span></code></a>.</p>
<p><strong>Return</strong></p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_end_signalling">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_end_signalling</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">cookie</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_end_signalling" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>end a critical DMA fence signalling section</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">cookie</span></code></dt><dd><p>opaque cookie from <a class="reference internal" href="#c.dma_fence_begin_signalling" title="dma_fence_begin_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_begin_signalling()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Closes a critical section annotation opened by <a class="reference internal" href="#c.dma_fence_begin_signalling" title="dma_fence_begin_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_begin_signalling()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_signal_timestamp_locked">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_signal_timestamp_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">timestamp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_signal_timestamp_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>signal completion of a fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">timestamp</span></code></dt><dd><p>fence signal timestamp in kernel’s CLOCK_MONOTONIC time domain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal completion for software callbacks on a fence, this will unblock
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> calls and run all the callbacks added with
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>. Can be called multiple times, but since a fence
can only go from the unsignaled to the signaled state and not back, it will
only be effective the first time. Set the timestamp provided as the fence
signal timestamp.</p>
<p>Unlike <a class="reference internal" href="#c.dma_fence_signal_timestamp" title="dma_fence_signal_timestamp"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal_timestamp()</span></code></a>, this function must be called with
<a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.lock</span></code></a> held.</p>
<p>Returns 0 on success and a negative error value when <strong>fence</strong> has been
signalled already.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_signal_timestamp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_signal_timestamp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">timestamp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_signal_timestamp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>signal completion of a fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">timestamp</span></code></dt><dd><p>fence signal timestamp in kernel’s CLOCK_MONOTONIC time domain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal completion for software callbacks on a fence, this will unblock
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> calls and run all the callbacks added with
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>. Can be called multiple times, but since a fence
can only go from the unsignaled to the signaled state and not back, it will
only be effective the first time. Set the timestamp provided as the fence
signal timestamp.</p>
<p>Returns 0 on success and a negative error value when <strong>fence</strong> has been
signalled already.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_signal_locked">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_signal_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_signal_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>signal completion of a fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to signal</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal completion for software callbacks on a fence, this will unblock
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> calls and run all the callbacks added with
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>. Can be called multiple times, but since a fence
can only go from the unsignaled to the signaled state and not back, it will
only be effective the first time.</p>
<p>Unlike <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>, this function must be called with <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.lock</span></code></a>
held.</p>
<p>Returns 0 on success and a negative error value when <strong>fence</strong> has been
signalled already.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_signal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_signal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_signal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>signal completion of a fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to signal</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal completion for software callbacks on a fence, this will unblock
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> calls and run all the callbacks added with
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>. Can be called multiple times, but since a fence
can only go from the unsignaled to the signaled state and not back, it will
only be effective the first time.</p>
<p>Returns 0 on success and a negative error value when <strong>fence</strong> has been
signalled already.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_wait_timeout">
<span class="kt"><span class="pre">signed</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_wait_timeout</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">intr</span></span>, <span class="kt"><span class="pre">signed</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_wait_timeout" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sleep until the fence gets signaled or until timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt><dd><p>if true, do an interruptible wait</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or the
remaining timeout in jiffies on success. Other error values may be
returned on custom implementations.</p>
<p>Performs a synchronous wait on this fence. It is assumed the caller
directly or indirectly (buf-mgr between reservation and committing)
holds a reference to the fence, otherwise the fence might be
freed before return, resulting in undefined behavior.</p>
<p>See also <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> and <a class="reference internal" href="#c.dma_fence_wait_any_timeout" title="dma_fence_wait_any_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait_any_timeout()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_release</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence_release" title="kref"><span class="n"><span class="pre">kref</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kref</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_release" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>default relese function for fences</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*kref</span></code></dt><dd><p><a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.recfount</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default release functions for <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a>. Drivers shouldn’t call
this directly, but instead call <a class="reference internal" href="#c.dma_fence_put" title="dma_fence_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_put()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>default release function for <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default implementation for <a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence_ops.release</span></code></a>. It calls
<a class="reference internal" href="../core-api/kernel-api.html#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> on <strong>fence</strong>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_enable_sw_signaling">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_enable_sw_signaling</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_enable_sw_signaling" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable signaling on fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will request for sw signaling to be enabled, to make the fence
complete as soon as possible. This calls <a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence_ops.enable_signaling</span></code></a>
internally.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_add_callback">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_add_callback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence_cb" title="dma_fence_cb"><span class="n"><span class="pre">dma_fence_cb</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cb</span></span>, <span class="n"><span class="pre">dma_fence_func_t</span></span><span class="w"> </span><span class="n"><span class="pre">func</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_add_callback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a callback to be called when the fence is signaled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_cb</span> <span class="pre">*cb</span></code></dt><dd><p>the callback to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_fence_func_t</span> <span class="pre">func</span></code></dt><dd><p>the function to call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a software callback to the fence. The caller should keep a reference to
the fence.</p>
<p><strong>cb</strong> will be initialized by <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>, no initialization
by the caller is required. Any number of callbacks can be registered
to a fence, but a callback can only be registered to one fence at a time.</p>
<p>If fence is already signaled, this function will return -ENOENT (and
<em>not</em> call the callback).</p>
<p>Note that the callback can be called from an atomic context or irq context.</p>
<p>Returns 0 in case of success, -ENOENT if the fence is already signaled
and -EINVAL in case of error.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_get_status">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_get_status</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_status" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns the status upon completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the dma_fence to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This wraps <a class="reference internal" href="#c.dma_fence_get_status_locked" title="dma_fence_get_status_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_get_status_locked()</span></code></a> to return the error status
condition on a signaled fence. See <a class="reference internal" href="#c.dma_fence_get_status_locked" title="dma_fence_get_status_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_get_status_locked()</span></code></a> for more
details.</p>
<p>Returns 0 if the fence has not yet been signaled, 1 if the fence has
been signaled without an error condition, or a negative error code
if the fence has been completed in err.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_remove_callback">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_remove_callback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence_cb" title="dma_fence_cb"><span class="n"><span class="pre">dma_fence_cb</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_remove_callback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove a callback from the signaling list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_cb</span> <span class="pre">*cb</span></code></dt><dd><p>the callback to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a previously queued callback from the fence. This function returns
true if the callback is successfully removed, or false if the fence has
already been signaled.</p>
<p><em>WARNING</em>:
Cancelling a callback should only be done if you really know what you’re
doing, since deadlocks and race conditions could occur all too easily. For
this reason, it should only ever be done on hardware lockup recovery,
with a reference held to the fence.</p>
<p>Behaviour is undefined if <strong>cb</strong> has not been added to <strong>fence</strong> using
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a> beforehand.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_default_wait">
<span class="kt"><span class="pre">signed</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_default_wait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">intr</span></span>, <span class="kt"><span class="pre">signed</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_default_wait" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>default sleep until the fence gets signaled or until timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt><dd><p>if true, do an interruptible wait</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or the
remaining timeout in jiffies on success. If timeout is zero the value one is
returned if the fence is already signaled for consistency with other
functions taking a jiffies timeout.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_wait_any_timeout">
<span class="kt"><span class="pre">signed</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_wait_any_timeout</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fences</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">intr</span></span>, <span class="kt"><span class="pre">signed</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_wait_any_timeout" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sleep until any fence gets signaled or until timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**fences</span></code></dt><dd><p>array of fences to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">count</span></code></dt><dd><p>number of fences to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt><dd><p>if true, do an interruptible wait</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">*idx</span></code></dt><dd><p>used to store the first signaled fence index, meaningful only on
positive return</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -EINVAL on custom fence wait implementation, -ERESTARTSYS if
interrupted, 0 if the wait timed out, or the remaining timeout in jiffies
on success.</p>
<p>Synchronous waits for the first fence in the array to be signaled. The
caller needs to hold a reference to all fences in the array, otherwise a
fence might be freed before return, resulting in undefined behavior.</p>
<p>See also <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> and <a class="reference internal" href="#c.dma_fence_wait_timeout" title="dma_fence_wait_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait_timeout()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops"><span class="n"><span class="pre">dma_fence_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="n"><span class="pre">spinlock_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lock</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">context</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">seqno</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a custom fence.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_fence_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the dma_fence_ops for operations on this fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>the irqsafe spinlock to use for locking this fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">context</span></code></dt><dd><p>the execution context this fence is run on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">seqno</span></code></dt><dd><p>a linear increasing sequence number for this context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes an allocated fence, the caller doesn’t have to keep its
refcount after committing with this fence, but it will need to hold a
refcount again if <a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence_ops.enable_signaling</span></code></a> gets called.</p>
<p>context and seqno are used for easy comparison between fences, allowing
to check which fence is later by simply using <a class="reference internal" href="#c.dma_fence_later" title="dma_fence_later"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_later()</span></code></a>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_fence">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence</span></span></span><a class="headerlink" href="#c.dma_fence" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>software synchronization primitive</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence {
  spinlock_t *lock;
  const struct dma_fence_ops *ops;
  union {
    struct list_head cb_list;
    ktime_t timestamp;
    struct rcu_head rcu;
  };
  u64 context;
  u64 seqno;
  unsigned long flags;
  struct kref refcount;
  int error;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>spin_lock_irqsave used for locking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>dma_fence_ops associated with this fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb_list</span></code></dt><dd><p>list of all callbacks to call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timestamp</span></code></dt><dd><p>Timestamp when the fence was signaled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt><dd><p>used for releasing fence with kfree_rcu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">context</span></code></dt><dd><p>execution context this fence belongs to, returned by
<a class="reference internal" href="#c.dma_fence_context_alloc" title="dma_fence_context_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_context_alloc()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seqno</span></code></dt><dd><p>the sequence number of this fence inside the execution context,
can be compared to decide which fence would be signaled later.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>A mask of DMA_FENCE_FLAG_* defined below</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt><dd><p>refcount for this fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">error</span></code></dt><dd><p>Optional, only valid if &lt; 0, must be set before calling
dma_fence_signal, indicates that the fence has completed with an error.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>the flags member must be manipulated and read using the appropriate
atomic ops (bit_*), so taking the spinlock will not be needed most
of the time.</p>
<p>DMA_FENCE_FLAG_SIGNALED_BIT - fence is already signaled
DMA_FENCE_FLAG_TIMESTAMP_BIT - timestamp recorded for fence signaling
DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT - enable_signaling might have been called
DMA_FENCE_FLAG_USER_BITS - start of the unused bits, can be used by the
implementer of the fence for its own purposes. Can be used in different
ways by different fence implementers, so do not rely on this.</p>
<p>Since atomic bitops are used, this is not guaranteed to be the case.
Particularly, if the bit was set, but dma_fence_signal was called right
before this bit was set, it would have been able to set the
DMA_FENCE_FLAG_SIGNALED_BIT, before enable_signaling was called.
Adding a check for DMA_FENCE_FLAG_SIGNALED_BIT after setting
DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT closes this race, and makes sure that
after dma_fence_signal was called, any enable_signaling call will have either
been completed, or never called at all.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_fence_cb">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_cb</span></span></span><a class="headerlink" href="#c.dma_fence_cb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>callback for <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a></p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence_cb {
  struct list_head node;
  dma_fence_func_t func;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>used by <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a> to append this struct to fence::cb_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">func</span></code></dt><dd><p>dma_fence_func_t to call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct will be initialized by <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>, additional
data can be passed along by embedding dma_fence_cb in another struct.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_fence_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_ops</span></span></span><a class="headerlink" href="#c.dma_fence_ops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>operations implemented for fence</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence_ops {
  bool use_64bit_seqno;
  const char * (*get_driver_name)(struct dma_fence *fence);
  const char * (*get_timeline_name)(struct dma_fence *fence);
  bool (*enable_signaling)(struct dma_fence *fence);
  bool (*signaled)(struct dma_fence *fence);
  signed long (*wait)(struct dma_fence *fence, bool intr, signed long timeout);
  void (*release)(struct dma_fence *fence);
  void (*fence_value_str)(struct dma_fence *fence, char *str, int size);
  void (*timeline_value_str)(struct dma_fence *fence, char *str, int size);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">use_64bit_seqno</span></code></dt><dd><p>True if this dma_fence implementation uses 64bit seqno, false
otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_driver_name</span></code></dt><dd><p>Returns the driver name. This is a callback to allow drivers to
compute the name at runtime, without having it to store permanently
for each fence, or build a cache of some sort.</p>
<p>This callback is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_timeline_name</span></code></dt><dd><p>Return the name of the context this fence belongs to. This is a
callback to allow drivers to compute the name at runtime, without
having it to store permanently for each fence, or build a cache of
some sort.</p>
<p>This callback is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_signaling</span></code></dt><dd><p>Enable software signaling of fence.</p>
<p>For fence implementations that have the capability for hw-&gt;hw
signaling, they can implement this op to enable the necessary
interrupts, or insert commands into cmdstream, etc, to avoid these
costly operations for the common case where only hw-&gt;hw
synchronization is required.  This is called in the first
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> or <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a> path to let the fence
implementation know that there is another driver waiting on the
signal (ie. hw-&gt;sw case).</p>
<p>This function can be called from atomic context, but not
from irq context, so normal spinlocks can be used.</p>
<p>A return value of false indicates the fence already passed,
or some failure occurred that made it impossible to enable
signaling. True indicates successful enabling.</p>
<p><a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.error</span></code></a> may be set in enable_signaling, but only when false
is returned.</p>
<p>Since many implementations can call <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> even when before
<strong>enable_signaling</strong> has been called there’s a race window, where the
<a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> might result in the final fence reference being
released and its memory freed. To avoid this, implementations of this
callback should grab their own reference using <a class="reference internal" href="#c.dma_fence_get" title="dma_fence_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_get()</span></code></a>, to be
released when the fence is signalled (through e.g. the interrupt
handler).</p>
<p>This callback is optional. If this callback is not present, then the
driver must always have signaling enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signaled</span></code></dt><dd><p>Peek whether the fence is signaled, as a fastpath optimization for
e.g. <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> or <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>. Note that this
callback does not need to make any guarantees beyond that a fence
once indicates as signalled must always return true from this
callback. This callback may return false even if the fence has
completed already, in this case information hasn’t propogated throug
the system yet. See also <a class="reference internal" href="#c.dma_fence_is_signaled" title="dma_fence_is_signaled"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_is_signaled()</span></code></a>.</p>
<p>May set <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.error</span></code></a> if returning true.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait</span></code></dt><dd><p>Custom wait implementation, defaults to <a class="reference internal" href="#c.dma_fence_default_wait" title="dma_fence_default_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_default_wait()</span></code></a> if
not set.</p>
<p>Deprecated and should not be used by new implementations. Only used
by existing implementations which need special handling for their
hardware reset procedure.</p>
<p>Must return -ERESTARTSYS if the wait is intr = true and the wait was
interrupted, and remaining jiffies if fence has signaled, or 0 if wait
timed out. Can also return other error values on custom implementations,
which should be treated as if the fence is signaled. For example a hardware
lockup could be reported like that.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>Called on destruction of fence to release additional resources.
Can be called from irq context.  This callback is optional. If it is
NULL, then <a class="reference internal" href="#c.dma_fence_free" title="dma_fence_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_free()</span></code></a> is instead called as the default
implementation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_value_str</span></code></dt><dd><p>Callback to fill in free-form debug info specific to this fence, like
the sequence number.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeline_value_str</span></code></dt><dd><p>Fills in the current value of the timeline as a string, like the
sequence number. Note that the specific fence passed to this function
should not matter, drivers should only use it to look up the
corresponding timeline structures.</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decreases refcount of the fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to reduce refcount of</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increases refcount of the fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to increase refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the same fence, with refcount increased by 1.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_get_rcu">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_get_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get a fence from a dma_resv_list with rcu read lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to increase refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns NULL if no refcount could be obtained, or the fence.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_get_rcu_safe">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_get_rcu_safe</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="pre">__rcu</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fencep</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_rcu_safe" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>acquire a reference to an RCU tracked fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">__rcu</span> <span class="pre">**fencep</span></code></dt><dd><p>pointer to fence to increase refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns NULL if no refcount could be obtained, or the fence.
This function handles acquiring a reference to a fence that may be
reallocated within the RCU grace period (such as with SLAB_TYPESAFE_BY_RCU),
so long as the caller is using RCU on the pointer to the fence.</p>
<p>An alternative mechanism is to employ a seqlock to protect a bunch of
fences, such as used by <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a>. When using a seqlock,
the seqlock must be taken before and checked after a reference to the
fence is acquired (as shown here).</p>
<p>The caller is required to hold the RCU read lock.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_is_signaled_locked">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_is_signaled_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_signaled_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return an indication if the fence is signaled yet.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the fence was already signaled, false if not. Since this
function doesn’t enable signaling, it is not guaranteed to ever return
true if <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>, <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> or
<a class="reference internal" href="#c.dma_fence_enable_sw_signaling" title="dma_fence_enable_sw_signaling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_enable_sw_signaling()</span></code></a> haven’t been called before.</p>
<p>This function requires <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.lock</span></code></a> to be held.</p>
<p>See also <a class="reference internal" href="#c.dma_fence_is_signaled" title="dma_fence_is_signaled"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_is_signaled()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_is_signaled">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_is_signaled</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_signaled" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return an indication if the fence is signaled yet.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the fence was already signaled, false if not. Since this
function doesn’t enable signaling, it is not guaranteed to ever return
true if <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>, <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> or
<a class="reference internal" href="#c.dma_fence_enable_sw_signaling" title="dma_fence_enable_sw_signaling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_enable_sw_signaling()</span></code></a> haven’t been called before.</p>
<p>It’s recommended for seqno fences to call dma_fence_signal when the
operation is complete, it makes it possible to prevent issues from
wraparound between time of issue and time of use by checking the return
value of this function before calling hardware-specific wait instructions.</p>
<p>See also <a class="reference internal" href="#c.dma_fence_is_signaled_locked" title="dma_fence_is_signaled_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_is_signaled_locked()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.__dma_fence_is_later">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__dma_fence_is_later</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">f1</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">f2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops"><span class="n"><span class="pre">dma_fence_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__dma_fence_is_later" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return if f1 is chronologically later than f2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">f1</span></code></dt><dd><p>the first fence’s seqno</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">f2</span></code></dt><dd><p>the second fence’s seqno from the same context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_fence_ops</span> <span class="pre">*ops</span></code></dt><dd><p>dma_fence_ops associated with the seqno</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if f1 is chronologically later than f2. Both fences must be
from the same context, since a seqno is not common across contexts.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_is_later">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_is_later</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f1</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_later" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return if f1 is chronologically later than f2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*f1</span></code></dt><dd><p>the first fence from the same context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*f2</span></code></dt><dd><p>the second fence from the same context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if f1 is chronologically later than f2. Both fences must be
from the same context, since a seqno is not re-used across contexts.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_later">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_later</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f1</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_later" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the chronologically later fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*f1</span></code></dt><dd><p>the first fence from the same context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*f2</span></code></dt><dd><p>the second fence from the same context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if both fences are signaled, otherwise the fence that would be
signaled last. Both fences must be from the same context, since a seqno is
not re-used across contexts.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_get_status_locked">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_get_status_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_status_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns the status upon completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the dma_fence to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can supply an optional error status condition before they signal
the fence (to indicate whether the fence was completed due to an error
rather than success). The value of the status condition is only valid
if the fence has been signaled, <a class="reference internal" href="#c.dma_fence_get_status_locked" title="dma_fence_get_status_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_get_status_locked()</span></code></a> first checks
the signal state before reporting the error status.</p>
<p>Returns 0 if the fence has not yet been signaled, 1 if the fence has
been signaled without an error condition, or a negative error code
if the fence has been completed in err.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_set_error">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_set_error</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">error</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_set_error" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>flag an error condition on the fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the dma_fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">error</span></code></dt><dd><p>the error to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can supply an optional error status condition before they signal
the fence, to indicate that the fence was completed due to an error
rather than success. This must be set before signaling (so that the value
is visible before any waiters on the signal callback are woken). This
helper exists to help catching erroneous setting of #dma_fence.error.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_wait">
<span class="kt"><span class="pre">signed</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_wait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">intr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_wait" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sleep until the fence gets signaled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt><dd><p>if true, do an interruptible wait</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will return -ERESTARTSYS if interrupted by a signal,
or 0 if the fence was signaled. Other error values may be
returned on custom implementations.</p>
<p>Performs a synchronous wait on this fence. It is assumed the caller
directly or indirectly holds a reference to the fence, otherwise the
fence might be freed before return, resulting in undefined behavior.</p>
<p>See also <a class="reference internal" href="#c.dma_fence_wait_timeout" title="dma_fence_wait_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait_timeout()</span></code></a> and <a class="reference internal" href="#c.dma_fence_wait_any_timeout" title="dma_fence_wait_any_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait_any_timeout()</span></code></a>.</p>
</div>
<div class="section" id="dma-fence-array">
<h3>DMA Fence Array<a class="headerlink" href="#dma-fence-array" title="Permalink to this headline">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_array_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence_array" title="dma_fence_array"><span class="n"><span class="pre">dma_fence_array</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_array_create</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_fences</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fences</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">context</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">seqno</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">signal_on_any</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_array_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a custom fence array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_fences</span></code></dt><dd><p>[in]    number of fences to add in the array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**fences</span></code></dt><dd><p>[in]    array containing the fences</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">context</span></code></dt><dd><p>[in]    fence context to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">seqno</span></code></dt><dd><p>[in]    sequence number to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">signal_on_any</span></code></dt><dd><p>[in]    signal on any fence in the array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a dma_fence_array object and initialize the base fence with
<a class="reference internal" href="#c.dma_fence_init" title="dma_fence_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_init()</span></code></a>.
In case of error it returns NULL.</p>
<p>The caller should allocate the fences array with num_fences size
and fill it with the fences it wants to add to the object. Ownership of this
array is taken and <a class="reference internal" href="#c.dma_fence_put" title="dma_fence_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_put()</span></code></a> is used on each fence on release.</p>
<p>If <strong>signal_on_any</strong> is true the fence array signals if any fence in the array
signals, otherwise it signals when all fences in the array signal.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_match_context">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_match_context</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">context</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_match_context" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if all fences are from the given context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>[in]    fence or fence array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">context</span></code></dt><dd><p>[in]    fence context to check all fences against</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks the provided fence or, for a fence array, all fences in the array
against the given context. Returns false if any fence is from a different
context.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_fence_array_cb">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_array_cb</span></span></span><a class="headerlink" href="#c.dma_fence_array_cb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>callback helper for fence array</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence_array_cb {
  struct dma_fence_cb cb;
  struct dma_fence_array *array;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt><dd><p>fence callback structure for signaling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">array</span></code></dt><dd><p>reference to the parent fence array object</p>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_fence_array">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_array</span></span></span><a class="headerlink" href="#c.dma_fence_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fence to represent an array of fences</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence_array {
  struct dma_fence base;
  spinlock_t lock;
  unsigned num_fences;
  atomic_t num_pending;
  struct dma_fence **fences;
  struct irq_work work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>fence base class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>spinlock for fence handling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_fences</span></code></dt><dd><p>number of fences in the array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_pending</span></code></dt><dd><p>fences in the array still pending</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fences</span></code></dt><dd><p>array of the fences</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>internal irq_work function</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_is_array">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_is_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if a fence is from the array subsclass</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if it is a dma_fence_array and false otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.to_dma_fence_array">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence_array" title="dma_fence_array"><span class="n"><span class="pre">dma_fence_array</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">to_dma_fence_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.to_dma_fence_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cast a fence to a dma_fence_array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to cast to a dma_fence_array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the fence is not a dma_fence_array,
or the dma_fence_array otherwise.</p>
</div>
<div class="section" id="dma-fence-chain">
<h3>DMA Fence Chain<a class="headerlink" href="#dma-fence-chain" title="Permalink to this headline">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_chain_walk">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_chain_walk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_walk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>chain walking function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>current chain node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the chain to the next node. Returns the next fence or NULL if we are at
the end of the chain. Garbage collects chain nodes which are already
signaled.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_chain_find_seqno">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_chain_find_seqno</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pfence</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">seqno</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_find_seqno" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find fence chain node by seqno</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**pfence</span></code></dt><dd><p>pointer to the chain node where to start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">seqno</span></code></dt><dd><p>the sequence number to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Advance the fence pointer to the chain node which will signal this sequence
number. If no sequence number is provided then this is a no-op.</p>
<p>Returns EINVAL if the fence is not a chain node or the sequence number has
not yet advanced far enough.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_chain_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_chain_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain"><span class="n"><span class="pre">dma_fence_chain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chain</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">seqno</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize a fence chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_chain</span> <span class="pre">*chain</span></code></dt><dd><p>the chain node to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*prev</span></code></dt><dd><p>the previous fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the current fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">seqno</span></code></dt><dd><p>the sequence number to use for the fence chain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a new chain node and either start a new chain or add the node to
the existing chain of the previous fence.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dma_fence_chain">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_chain</span></span></span><a class="headerlink" href="#c.dma_fence_chain" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fence to represent an node of a fence chain</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence_chain {
  struct dma_fence base;
  struct dma_fence __rcu *prev;
  u64 prev_seqno;
  struct dma_fence *fence;
  union {
    struct dma_fence_cb cb;
    struct irq_work work;
  };
  spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>fence base class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prev</span></code></dt><dd><p>previous fence of the chain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prev_seqno</span></code></dt><dd><p>original previous seqno before garbage collection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>encapsulated fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt><dd><p>callback for signaling</p>
<p>This is used to add the callback for signaling the
complection of the fence chain. Never used at the same time
as the irq work.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>irq work item for signaling</p>
<p>Irq work structure to allow us to add the callback without
running into lock inversion. Never used at the same time as
the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>spinlock for fence handling</p>
</dd>
</dl>
<dl class="c function">
<dt class="sig sig-object c" id="c.to_dma_fence_chain">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain"><span class="n"><span class="pre">dma_fence_chain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">to_dma_fence_chain</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.to_dma_fence_chain" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cast a fence to a dma_fence_chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to cast to a dma_fence_array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the fence is not a dma_fence_chain,
or the dma_fence_chain otherwise.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_chain_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain"><span class="n"><span class="pre">dma_fence_chain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_chain_alloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a new <a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_chain</span></code></a> object or NULL on failure.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_fence_chain_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_fence_chain_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain"><span class="n"><span class="pre">dma_fence_chain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chain</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_free" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_chain</span> <span class="pre">*chain</span></code></dt><dd><p>chain node to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees up an allocated but not used <a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_chain</span></code></a> object. This
doesn’t need an RCU grace period since the fence was never initialized nor
published. After <a class="reference internal" href="#c.dma_fence_chain_init" title="dma_fence_chain_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_chain_init()</span></code></a> has been called the fence must be
released by calling <a class="reference internal" href="#c.dma_fence_put" title="dma_fence_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_put()</span></code></a>, and not through this function.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.dma_fence_chain_for_each">
<span class="sig-name descname"><span class="n"><span class="pre">dma_fence_chain_for_each</span></span></span><a class="headerlink" href="#c.dma_fence_chain_for_each" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">dma_fence_chain_for_each</span> <span class="pre">(iter,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>iterate over all fences in chain</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">iter</span></code></dt><dd><p>current fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>starting point</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all fences in the chain. We keep a reference to the current
fence while inside the loop which must be dropped when breaking out.</p>
</div>
<div class="section" id="dma-fence-uabi-sync-file">
<h3>DMA Fence uABI/Sync File<a class="headerlink" href="#dma-fence-uabi-sync-file" title="Permalink to this headline">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.sync_file_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.sync_file" title="sync_file"><span class="n"><span class="pre">sync_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sync_file_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_file_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>creates a sync file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to add to the sync_fence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a sync_file containg <strong>fence</strong>. This function acquires and additional
reference of <strong>fence</strong> for the newly-created <a class="reference internal" href="#c.sync_file" title="sync_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">sync_file</span></code></a>, if it succeeds. The
sync_file can be released with fput(sync_file-&gt;file). Returns the
sync_file or NULL in case of error.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.sync_file_get_fence">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sync_file_get_fence</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">fd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_file_get_fence" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the fence related to the sync_file fd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>sync_file fd to get the fence from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ensures <strong>fd</strong> references a valid sync_file and returns a fence that
represents all fence in the sync_file. On error NULL is returned.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.sync_file">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sync_file</span></span></span><a class="headerlink" href="#c.sync_file" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sync file to export to the userspace</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sync_file {
  struct file             *file;
  char user_name[32];
#ifdef CONFIG_DEBUG_FS;
  struct list_head        sync_file_list;
#endif;
  wait_queue_head_t wq;
  unsigned long           flags;
  struct dma_fence        *fence;
  struct dma_fence_cb cb;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>file representing this fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">user_name</span></code></dt><dd><p>Name of the sync file provided by userspace, for merged fences.
Otherwise generated through driver callbacks (in which case the
entire array is 0).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sync_file_list</span></code></dt><dd><p>membership in global file list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>wait queue for fence signaling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags for the sync_file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>fence with the fences in the sync_file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt><dd><p>fence callback information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>flags:
POLL_ENABLED: whether userspace is currently poll()’ing or not</p>
</div>
<div class="section" id="indefinite-dma-fences">
<h3>Indefinite DMA Fences<a class="headerlink" href="#indefinite-dma-fences" title="Permalink to this headline">¶</a></h3>
<p>At various times <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span></code></a> with an indefinite time until <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a>
finishes have been proposed. Examples include:</p>
<ul class="simple">
<li><p>Future fences, used in HWC1 to signal when a buffer isn’t used by the display
any longer, and created with the screen update that makes the buffer visible.
The time this fence completes is entirely under userspace’s control.</p></li>
<li><p>Proxy fences, proposed to handle &amp;drm_syncobj for which the fence has not yet
been set. Used to asynchronously delay command submission.</p></li>
<li><p>Userspace fences or gpu futexes, fine-grained locking within a command buffer
that userspace uses for synchronization across engines or with the CPU, which
are then imported as a DMA fence for integration into existing winsys
protocols.</p></li>
<li><p>Long-running compute command buffers, while still using traditional end of
batch DMA fences for memory management instead of context preemption DMA
fences which get reattached when the compute job is rescheduled.</p></li>
</ul>
<p>Common to all these schemes is that userspace controls the dependencies of these
fences and controls when they fire. Mixing indefinite fences with normal
in-kernel DMA fences does not work, even when a fallback timeout is included to
protect against malicious userspace:</p>
<ul class="simple">
<li><p>Only the kernel knows about all DMA fence dependencies, userspace is not aware
of dependencies injected due to memory management or scheduler decisions.</p></li>
<li><p>Only userspace knows about all dependencies in indefinite fences and when
exactly they will complete, the kernel has no visibility.</p></li>
</ul>
<p>Furthermore the kernel has to be able to hold up userspace command submission
for memory management needs, which means we must support indefinite fences being
dependent upon DMA fences. If the kernel also support indefinite fences in the
kernel like a DMA fence, like any of the above proposal would, there is the
potential for deadlocks.</p>
<div class="figure align-default" id="id1">
<img alt="Indefinite Fencing Dependency Cycle" src="../_images/DOT-e8ff13d1f6d4fbb7ed4e8bcd73fc8bed4777de4f.svg" /><p class="caption"><span class="caption-text">Indefinite Fencing Dependency Cycle</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>This means that the kernel might accidentally create deadlocks
through memory management dependencies which userspace is unaware of, which
randomly hangs workloads until the timeout kicks in. Workloads, which from
userspace’s perspective, do not contain a deadlock.  In such a mixed fencing
architecture there is no single entity with knowledge of all dependencies.
Thefore preventing such deadlocks from within the kernel is not possible.</p>
<p>The only solution to avoid dependencies loops is by not allowing indefinite
fences in the kernel. This means:</p>
<ul class="simple">
<li><p>No future fences, proxy fences or userspace fences imported as DMA fences,
with or without a timeout.</p></li>
<li><p>No DMA fences that signal end of batchbuffer for command submission where
userspace is allowed to use userspace fencing or long running compute
workloads. This also means no implicit fencing for shared buffers in these
cases.</p></li>
</ul>
</div>
<div class="section" id="recoverable-hardware-page-faults-implications">
<h3>Recoverable Hardware Page Faults Implications<a class="headerlink" href="#recoverable-hardware-page-faults-implications" title="Permalink to this headline">¶</a></h3>
<p>Modern hardware supports recoverable page faults, which has a lot of
implications for DMA fences.</p>
<p>First, a pending page fault obviously holds up the work that’s running on the
accelerator and a memory allocation is usually required to resolve the fault.
But memory allocations are not allowed to gate completion of DMA fences, which
means any workload using recoverable page faults cannot use DMA fences for
synchronization. Synchronization fences controlled by userspace must be used
instead.</p>
<p>On GPUs this poses a problem, because current desktop compositor protocols on
Linux rely on DMA fences, which means without an entirely new userspace stack
built on top of userspace fences, they cannot benefit from recoverable page
faults. Specifically this means implicit synchronization will not be possible.
The exception is when page faults are only used as migration hints and never to
on-demand fill a memory request. For now this means recoverable page
faults on GPUs are limited to pure compute workloads.</p>
<p>Furthermore GPUs usually have shared resources between the 3D rendering and
compute side, like compute units or command submission engines. If both a 3D
job with a DMA fence and a compute workload using recoverable page faults are
pending they could deadlock:</p>
<ul class="simple">
<li><p>The 3D workload might need to wait for the compute job to finish and release
hardware resources first.</p></li>
<li><p>The compute workload might be stuck in a page fault, because the memory
allocation is waiting for the DMA fence of the 3D workload to complete.</p></li>
</ul>
<p>There are a few options to prevent this problem, one of which drivers need to
ensure:</p>
<ul class="simple">
<li><p>Compute workloads can always be preempted, even when a page fault is pending
and not yet repaired. Not all hardware supports this.</p></li>
<li><p>DMA fence workloads and workloads which need page fault handling have
independent hardware resources to guarantee forward progress. This could be
achieved through e.g. through dedicated engines and minimal compute unit
reservations for DMA fence workloads.</p></li>
<li><p>The reservation approach could be further refined by only reserving the
hardware resources for DMA fence workloads when they are in-flight. This must
cover the time from when the DMA fence is visible to other threads up to
moment when fence is completed through <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>.</p></li>
<li><p>As a last resort, if the hardware provides no useful reservation mechanics,
all workloads must be flushed from the GPU when switching between jobs
requiring DMA fences or jobs requiring page fault handling: This means all DMA
fences must complete before a compute job with page fault handling can be
inserted into the scheduler queue. And vice versa, before a DMA fence can be
made visible anywhere in the system, all compute workloads must be preempted
to guarantee all pending GPU page faults are flushed.</p></li>
<li><p>Only a fairly theoretical option would be to untangle these dependencies when
allocating memory to repair hardware page faults, either through separate
memory blocks or runtime tracking of the full dependency graph of all DMA
fences. This results very wide impact on the kernel, since resolving the page
on the CPU side can itself involve a page fault. It is much more feasible and
robust to limit the impact of handling hardware page faults to the specific
driver.</p></li>
</ul>
<p>Note that workloads that run on independent hardware like copy engines or other
GPUs do not have any impact. This allows us to keep using DMA fences internally
in the kernel even for resolving hardware page faults, e.g. by using copy
engines to clear or copy memory needed to resolve the page fault.</p>
<p>In some ways this page fault problem is a special case of the <cite>Infinite DMA
Fences</cite> discussions: Infinite fences from compute workloads are allowed to
depend on DMA fences, but not the other way around. And not even the page fault
problem is new, because some other CPU thread in userspace might
hit a page fault which holds up a userspace fence - supporting page faults on
GPUs doesn’t anything fundamentally new.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="device_link.html" class="btn btn-neutral float-right" title="Device links" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="device-io.html" class="btn btn-neutral float-left" title="Bus-Independent Device Accesses" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>