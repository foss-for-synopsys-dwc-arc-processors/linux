

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>NETWORK FILESYSTEM HELPER LIBRARY &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="v9fs: Plan 9 Resource Sharing for Linux" href="9p.html" />
    <link rel="prev" title="fs-verity: read-only file-based authenticity protection" href="fsverity.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.16.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Filesystems in the Linux kernel</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-vfs-documentation">Core VFS documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#filesystem-support-layers">Filesystem support layers</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="journalling.html">The Linux Journalling API</a></li>
<li class="toctree-l3"><a class="reference internal" href="fscrypt.html">Filesystem-level encryption (fscrypt)</a></li>
<li class="toctree-l3"><a class="reference internal" href="fsverity.html">fs-verity: read-only file-based authenticity protection</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">NETWORK FILESYSTEM HELPER LIBRARY</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffered-read-helpers">Buffered Read Helpers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#filesystems">Filesystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Filesystems in the Linux kernel</a> &raquo;</li>
        
      <li>NETWORK FILESYSTEM HELPER LIBRARY</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/filesystems/netfs_library.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="network-filesystem-helper-library">
<h1>NETWORK FILESYSTEM HELPER LIBRARY<a class="headerlink" href="#network-filesystem-helper-library" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The network filesystem helper library is a set of functions designed to aid a
network filesystem in implementing VM/VFS operations.  For the moment, that
just includes turning various VM buffered read operations into requests to read
from the server.  The helper library, however, can also interpose other
services, such as local caching or local data encryption.</p>
<p>Note that the library module doesn’t link against local caching directly, so
access must be provided by the netfs.</p>
</section>
<section id="buffered-read-helpers">
<h2>Buffered Read Helpers<a class="headerlink" href="#buffered-read-helpers" title="Permalink to this headline">¶</a></h2>
<p>The library provides a set of read helpers that handle the -&gt;readpage(),
-&gt;readahead() and much of the -&gt;write_begin() VM operations and translate them
into a common call framework.</p>
<p>The following services are provided:</p>
<blockquote>
<div><ul class="simple">
<li><p>Handles transparent huge pages (THPs).</p></li>
<li><p>Insulates the netfs from VM interface changes.</p></li>
<li><p>Allows the netfs to arbitrarily split reads up into pieces, even ones that
don’t match page sizes or page alignments and that may cross pages.</p></li>
<li><p>Allows the netfs to expand a readahead request in both directions to meet
its needs.</p></li>
<li><p>Allows the netfs to partially fulfil a read, which will then be resubmitted.</p></li>
<li><p>Handles local caching, allowing cached data and server-read data to be
interleaved for a single request.</p></li>
<li><p>Handles clearing of bufferage that aren’t on the server.</p></li>
<li><p>Handle retrying of reads that failed, switching reads from the cache to the
server as necessary.</p></li>
<li><p>In the future, this is a place that other services can be performed, such as
local encryption of data to be stored remotely or in the cache.</p></li>
</ul>
</div></blockquote>
<p>From the network filesystem, the helpers require a table of operations.  This
includes a mandatory method to issue a read operation along with a number of
optional methods.</p>
<section id="read-helper-functions">
<h3>Read Helper Functions<a class="headerlink" href="#read-helper-functions" title="Permalink to this headline">¶</a></h3>
<p>Three read helpers are provided:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* void netfs_readahead(struct readahead_control *ractl,
                       const struct netfs_read_request_ops *ops,
                       void *netfs_priv);``
* int netfs_readpage(struct file *file,
                     struct page *page,
                     const struct netfs_read_request_ops *ops,
                     void *netfs_priv);
* int netfs_write_begin(struct file *file,
                        struct address_space *mapping,
                        loff_t pos,
                        unsigned int len,
                        unsigned int flags,
                        struct page **_page,
                        void **_fsdata,
                        const struct netfs_read_request_ops *ops,
                        void *netfs_priv);
</pre></div>
</div>
<p>Each corresponds to a VM operation, with the addition of a couple of parameters
for the use of the read helpers:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">ops</span></code></p>
<p>A table of operations through which the helpers can talk to the filesystem.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">netfs_priv</span></code></p>
<p>Filesystem private data (can be NULL).</p>
</li>
</ul>
</div></blockquote>
<p>Both of these values will be stored into the read request structure.</p>
<p>For -&gt;readahead() and -&gt;readpage(), the network filesystem should just jump
into the corresponding read helper; whereas for -&gt;write_begin(), it may be a
little more complicated as the network filesystem might want to flush
conflicting writes or track dirty data and needs to put the acquired page if an
error occurs after calling the helper.</p>
<p>The helpers manage the read request, calling back into the network filesystem
through the suppplied table of operations.  Waits will be performed as
necessary before returning for helpers that are meant to be synchronous.</p>
<p>If an error occurs and netfs_priv is non-NULL, ops-&gt;cleanup() will be called to
deal with it.  If some parts of the request are in progress when an error
occurs, the request will get partially completed if sufficient data is read.</p>
<p>Additionally, there is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* void netfs_subreq_terminated(struct netfs_read_subrequest *subreq,
                               ssize_t transferred_or_error,
                               bool was_async);
</pre></div>
</div>
<p>which should be called to complete a read subrequest.  This is given the number
of bytes transferred or a negative error code, plus a flag indicating whether
the operation was asynchronous (ie. whether the follow-on processing can be
done in the current context, given this may involve sleeping).</p>
</section>
<section id="read-helper-structures">
<h3>Read Helper Structures<a class="headerlink" href="#read-helper-structures" title="Permalink to this headline">¶</a></h3>
<p>The read helpers make use of a couple of structures to maintain the state of
the read.  The first is a structure that manages a read request as a whole:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_read_request {
        struct inode            *inode;
        struct address_space    *mapping;
        struct netfs_cache_resources cache_resources;
        void                    *netfs_priv;
        loff_t                  start;
        size_t                  len;
        loff_t                  i_size;
        const struct netfs_read_request_ops *netfs_ops;
        unsigned int            debug_id;
        ...
};
</pre></div>
</div>
<p>The above fields are the ones the netfs can use.  They are:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">inode</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mapping</span></code></p>
<p>The inode and the address space of the file being read from.  The mapping
may or may not point to inode-&gt;i_data.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cache_resources</span></code></p>
<p>Resources for the local cache to use, if present.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">netfs_priv</span></code></p>
<p>The network filesystem’s private data.  The value for this can be passed in
to the helper functions or set during the request.  The -&gt;cleanup() op will
be called if this is non-NULL at the end.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">len</span></code></p>
<p>The file position of the start of the read request and the length.  These
may be altered by the -&gt;expand_readahead() op.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">i_size</span></code></p>
<p>The size of the file at the start of the request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">netfs_ops</span></code></p>
<p>A pointer to the operation table.  The value for this is passed into the
helper functions.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">debug_id</span></code></p>
<p>A number allocated to this operation that can be displayed in trace lines
for reference.</p>
</li>
</ul>
</div></blockquote>
<p>The second structure is used to manage individual slices of the overall read
request:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_read_subrequest {
        struct netfs_read_request *rreq;
        loff_t                  start;
        size_t                  len;
        size_t                  transferred;
        unsigned long           flags;
        unsigned short          debug_index;
        ...
};
</pre></div>
</div>
<p>Each subrequest is expected to access a single source, though the helpers will
handle falling back from one source type to another.  The members are:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">rreq</span></code></p>
<p>A pointer to the read request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">len</span></code></p>
<p>The file position of the start of this slice of the read request and the
length.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">transferred</span></code></p>
<p>The amount of data transferred so far of the length of this slice.  The
network filesystem or cache should start the operation this far into the
slice.  If a short read occurs, the helpers will call again, having updated
this to reflect the amount read so far.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">flags</span></code></p>
<p>Flags pertaining to the read.  There are two of interest to the filesystem
or cache:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_SREQ_CLEAR_TAIL</span></code></p>
<p>This can be set to indicate that the remainder of the slice, from
transferred to len, should be cleared.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_SREQ_SEEK_DATA_READ</span></code></p>
<p>This is a hint to the cache that it might want to try skipping ahead to
the next data (ie. using SEEK_DATA).</p>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">debug_index</span></code></p>
<p>A number allocated to this slice that can be displayed in trace lines for
reference.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="read-helper-operations">
<h3>Read Helper Operations<a class="headerlink" href="#read-helper-operations" title="Permalink to this headline">¶</a></h3>
<p>The network filesystem must provide the read helpers with a table of operations
through which it can issue requests and negotiate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_read_request_ops {
        void (*init_rreq)(struct netfs_read_request *rreq, struct file *file);
        bool (*is_cache_enabled)(struct inode *inode);
        int (*begin_cache_operation)(struct netfs_read_request *rreq);
        void (*expand_readahead)(struct netfs_read_request *rreq);
        bool (*clamp_length)(struct netfs_read_subrequest *subreq);
        void (*issue_op)(struct netfs_read_subrequest *subreq);
        bool (*is_still_valid)(struct netfs_read_request *rreq);
        int (*check_write_begin)(struct file *file, loff_t pos, unsigned len,
                                 struct page *page, void **_fsdata);
        void (*done)(struct netfs_read_request *rreq);
        void (*cleanup)(struct address_space *mapping, void *netfs_priv);
};
</pre></div>
</div>
<p>The operations are as follows:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">init_rreq()</span></code></p>
<p>[Optional] This is called to initialise the request structure.  It is given
the file for reference and can modify the -&gt;netfs_priv value.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_cache_enabled()</span></code></p>
<p>[Required] This is called by netfs_write_begin() to ask if the file is being
cached.  It should return true if it is being cached and false otherwise.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">begin_cache_operation()</span></code></p>
<p>[Optional] This is called to ask the network filesystem to call into the
cache (if present) to initialise the caching state for this read.  The netfs
library module cannot access the cache directly, so the cache should call
something like fscache_begin_read_operation() to do this.</p>
<p>The cache gets to store its state in -&gt;cache_resources and must set a table
of operations of its own there (though of a different type).</p>
<p>This should return 0 on success and an error code otherwise.  If an error is
reported, the operation may proceed anyway, just without local caching (only
out of memory and interruption errors cause failure here).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">expand_readahead()</span></code></p>
<p>[Optional] This is called to allow the filesystem to expand the size of a
readahead read request.  The filesystem gets to expand the request in both
directions, though it’s not permitted to reduce it as the numbers may
represent an allocation already made.  If local caching is enabled, it gets
to expand the request first.</p>
<p>Expansion is communicated by changing -&gt;start and -&gt;len in the request
structure.  Note that if any change is made, -&gt;len must be increased by at
least as much as -&gt;start is reduced.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">clamp_length()</span></code></p>
<p>[Optional] This is called to allow the filesystem to reduce the size of a
subrequest.  The filesystem can use this, for example, to chop up a request
that has to be split across multiple servers or to put multiple reads in
flight.</p>
<p>This should return 0 on success and an error code on error.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">issue_op()</span></code></p>
<p>[Required] The helpers use this to dispatch a subrequest to the server for
reading.  In the subrequest, -&gt;start, -&gt;len and -&gt;transferred indicate what
data should be read from the server.</p>
<p>There is no return value; the netfs_subreq_terminated() function should be
called to indicate whether or not the operation succeeded and how much data
it transferred.  The filesystem also should not deal with setting pages
uptodate, unlocking them or dropping their refs - the helpers need to deal
with this as they have to coordinate with copying to the local cache.</p>
<p>Note that the helpers have the pages locked, but not pinned.  It is possible
to use the ITER_XARRAY iov iterator to refer to the range of the inode that
is being operated upon without the need to allocate large bvec tables.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_still_valid()</span></code></p>
<p>[Optional] This is called to find out if the data just read from the local
cache is still valid.  It should return true if it is still valid and false
if not.  If it’s not still valid, it will be reread from the server.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_write_begin()</span></code></p>
<p>[Optional] This is called from the netfs_write_begin() helper once it has
allocated/grabbed the page to be modified to allow the filesystem to flush
conflicting state before allowing it to be modified.</p>
<p>It should return 0 if everything is now fine, -EAGAIN if the page should be
regrabbed and any other error code to abort the operation.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">done</span></code></p>
<p>[Optional] This is called after the pages in the request have all been
unlocked (and marked uptodate if applicable).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cleanup</span></code></p>
<p>[Optional] This is called as the request is being deallocated so that the
filesystem can clean up -&gt;netfs_priv.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="read-helper-procedure">
<h3>Read Helper Procedure<a class="headerlink" href="#read-helper-procedure" title="Permalink to this headline">¶</a></h3>
<p>The read helpers work by the following general procedure:</p>
<blockquote>
<div><ul class="simple">
<li><p>Set up the request.</p></li>
<li><p>For readahead, allow the local cache and then the network filesystem to
propose expansions to the read request.  This is then proposed to the VM.
If the VM cannot fully perform the expansion, a partially expanded read will
be performed, though this may not get written to the cache in its entirety.</p></li>
<li><p>Loop around slicing chunks off of the request to form subrequests:</p>
<ul>
<li><p>If a local cache is present, it gets to do the slicing, otherwise the
helpers just try to generate maximal slices.</p></li>
<li><p>The network filesystem gets to clamp the size of each slice if it is to be
the source.  This allows rsize and chunking to be implemented.</p></li>
<li><p>The helpers issue a read from the cache or a read from the server or just
clears the slice as appropriate.</p></li>
<li><p>The next slice begins at the end of the last one.</p></li>
<li><p>As slices finish being read, they terminate.</p></li>
</ul>
</li>
<li><p>When all the subrequests have terminated, the subrequests are assessed and
any that are short or have failed are reissued:</p>
<ul>
<li><p>Failed cache requests are issued against the server instead.</p></li>
<li><p>Failed server requests just fail.</p></li>
<li><p>Short reads against either source will be reissued against that source
provided they have transferred some more data:</p>
<ul>
<li><p>The cache may need to skip holes that it can’t do DIO from.</p></li>
<li><p>If NETFS_SREQ_CLEAR_TAIL was set, a short read will be cleared to the
end of the slice instead of reissuing.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Once the data is read, the pages that have been fully read/cleared:</p>
<ul>
<li><p>Will be marked uptodate.</p></li>
<li><p>If a cache is present, will be marked with PG_fscache.</p></li>
<li><p>Unlocked</p></li>
</ul>
</li>
<li><p>Any pages that need writing to the cache will then have DIO writes issued.</p></li>
<li><p>Synchronous operations will wait for reading to be complete.</p></li>
<li><p>Writes to the cache will proceed asynchronously and the pages will have the
PG_fscache mark removed when that completes.</p></li>
<li><p>The request structures will be cleaned up when everything has completed.</p></li>
</ul>
</div></blockquote>
</section>
<section id="read-helper-cache-api">
<h3>Read Helper Cache API<a class="headerlink" href="#read-helper-cache-api" title="Permalink to this headline">¶</a></h3>
<p>When implementing a local cache to be used by the read helpers, two things are
required: some way for the network filesystem to initialise the caching for a
read request and a table of operations for the helpers to call.</p>
<p>The network filesystem’s -&gt;begin_cache_operation() method is called to set up a
cache and this must call into the cache to do the work.  If using fscache, for
example, the cache would call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_begin_read_operation(struct netfs_read_request *rreq,
                                 struct fscache_cookie *cookie);
</pre></div>
</div>
<p>passing in the request pointer and the cookie corresponding to the file.</p>
<p>The netfs_read_request object contains a place for the cache to hang its
state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_cache_resources {
        const struct netfs_cache_ops    *ops;
        void                            *cache_priv;
        void                            *cache_priv2;
};
</pre></div>
</div>
<p>This contains an operations table pointer and two private pointers.  The
operation table looks like the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_cache_ops {
        void (*end_operation)(struct netfs_cache_resources *cres);

        void (*expand_readahead)(struct netfs_cache_resources *cres,
                                 loff_t *_start, size_t *_len, loff_t i_size);

        enum netfs_read_source (*prepare_read)(struct netfs_read_subrequest *subreq,
                                               loff_t i_size);

        int (*read)(struct netfs_cache_resources *cres,
                    loff_t start_pos,
                    struct iov_iter *iter,
                    bool seek_data,
                    netfs_io_terminated_t term_func,
                    void *term_func_priv);

        int (*write)(struct netfs_cache_resources *cres,
                     loff_t start_pos,
                     struct iov_iter *iter,
                     netfs_io_terminated_t term_func,
                     void *term_func_priv);
};
</pre></div>
</div>
<p>With a termination handler function pointer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef void (*netfs_io_terminated_t)(void *priv,
                                      ssize_t transferred_or_error,
                                      bool was_async);
</pre></div>
</div>
<p>The methods defined in the table are:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">end_operation()</span></code></p>
<p>[Required] Called to clean up the resources at the end of the read request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">expand_readahead()</span></code></p>
<p>[Optional] Called at the beginning of a netfs_readahead() operation to allow
the cache to expand a request in either direction.  This allows the cache to
size the request appropriately for the cache granularity.</p>
<p>The function is passed poiners to the start and length in its parameters,
plus the size of the file for reference, and adjusts the start and length
appropriately.  It should return one of:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_FILL_WITH_ZEROES</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_DOWNLOAD_FROM_SERVER</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_READ_FROM_CACHE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_INVALID_READ</span></code></p></li>
</ul>
<p>to indicate whether the slice should just be cleared or whether it should be
downloaded from the server or read from the cache - or whether slicing
should be given up at the current point.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">prepare_read()</span></code></p>
<p>[Required] Called to configure the next slice of a request.  -&gt;start and
-&gt;len in the subrequest indicate where and how big the next slice can be;
the cache gets to reduce the length to match its granularity requirements.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">read()</span></code></p>
<p>[Required] Called to read from the cache.  The start file offset is given
along with an iterator to read to, which gives the length also.  It can be
given a hint requesting that it seek forward from that start position for
data.</p>
<p>Also provided is a pointer to a termination handler function and private
data to pass to that function.  The termination function should be called
with the number of bytes transferred or an error code, plus a flag
indicating whether the termination is definitely happening in the caller’s
context.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">write()</span></code></p>
<p>[Required] Called to write to the cache.  The start file offset is given
along with an iterator to write from, which gives the length also.</p>
<p>Also provided is a pointer to a termination handler function and private
data to pass to that function.  The termination function should be called
with the number of bytes transferred or an error code, plus a flag
indicating whether the termination is definitely happening in the caller’s
context.</p>
</li>
</ul>
</div></blockquote>
<p>Note that these methods are passed a pointer to the cache resource structure,
not the read request structure as they could be used in other situations where
there isn’t a read request structure as well, such as writing dirty data to the
cache.</p>
<dl class="c function">
<dt id="c.folio_start_fscache">
<span class="pre">void</span> <code class="sig-name descname"><span class="pre">folio_start_fscache</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.folio_start_fscache" title="folio"><span class="pre">folio</span></a> <span class="pre">*</span><em><span class="pre">folio</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_start_fscache" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start an fscache write on a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function before writing a folio to a local cache.  Starting a
second write before the first one finishes is not allowed.</p>
<dl class="c function">
<dt id="c.folio_end_fscache">
<span class="pre">void</span> <code class="sig-name descname"><span class="pre">folio_end_fscache</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.folio_end_fscache" title="folio"><span class="pre">folio</span></a> <span class="pre">*</span><em><span class="pre">folio</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_end_fscache" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>End an fscache write on a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function after the folio has been written to the local cache.
This will wake any sleepers waiting on this folio.</p>
<dl class="c function">
<dt id="c.folio_wait_fscache">
<span class="pre">void</span> <code class="sig-name descname"><span class="pre">folio_wait_fscache</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.folio_wait_fscache" title="folio"><span class="pre">folio</span></a> <span class="pre">*</span><em><span class="pre">folio</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_fscache" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for an fscache write on this folio to end.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If this folio is currently being written to a local cache, wait for
the write to finish.  Another write may start after this one finishes,
unless the caller holds the folio lock.</p>
<dl class="c function">
<dt id="c.folio_wait_fscache_killable">
<span class="pre">int</span> <code class="sig-name descname"><span class="pre">folio_wait_fscache_killable</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.folio_wait_fscache_killable" title="folio"><span class="pre">folio</span></a> <span class="pre">*</span><em><span class="pre">folio</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_fscache_killable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for an fscache write on this folio to end.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If this folio is currently being written to a local cache, wait
for the write to finish or for a fatal signal to be received.
Another write may start after this one finishes, unless the caller
holds the folio lock.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0 if successful.</p></li>
<li><p>-EINTR if a fatal signal was encountered.</p></li>
</ul>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="9p.html" class="btn btn-neutral float-right" title="v9fs: Plan 9 Resource Sharing for Linux" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="fsverity.html" class="btn btn-neutral float-left" title="fs-verity: read-only file-based authenticity protection" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>